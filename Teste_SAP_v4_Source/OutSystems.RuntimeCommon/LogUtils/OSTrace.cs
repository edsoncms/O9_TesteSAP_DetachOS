/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using OutSystems.RuntimeCommon.LogUtils;
using OutSystems.RuntimeCommon.Utils;

namespace OutSystems.RuntimeCommon {
    /// <summary>
    /// Class that contains the definitions for the OutSystems trace.
    /// </summary>

    public class OSTrace {

        private enum TraceCategory {
            ERROR,
            WARNING,
            Info,
            TimerStart,
            TimerEnd,
            Debug,
            Data,
        }

        private static class TraceCategoryExtensions {
            public static TraceLevel ToTraceLevel(TraceCategory category) {
                switch (category) {
                    case TraceCategory.ERROR:
                        return TraceLevel.Error;
                    case TraceCategory.WARNING:
                        return TraceLevel.Warning;
                    case TraceCategory.Info:
                        return TraceLevel.Info;
                    case TraceCategory.TimerStart:
                    case TraceCategory.TimerEnd:
                    case TraceCategory.Debug:
                        return TraceLevel.Verbose;
                    case TraceCategory.Data:
                        return  TraceLevel.Verbose;
                    default: // No category should fall here, but not throwing exception to avoid exception propagation in java
                        return TraceLevel.Verbose;
                }
            }
        }

        public class TimerObject : IDisposable {
            private string timerName;

            void IDisposable.Dispose() {
                End();
            }

            internal TimerObject(string timerName) {
                TimerStart(timerName);
                this.timerName = timerName;
            }

            public void End() {
                TimerEnd(timerName);
            }
        }

        public class PublishTimerObject : IDisposable {
            private string publishStep, eSpaceKey, extraInfo, parentStep;
            private bool fromSS, developmentMode;
            private TraceKind traceKind;

            void IDisposable.Dispose() {
                End();
            }

            internal PublishTimerObject(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, TraceKind traceKind, string extraInfo, string parentStep) {
                if (!eSpaceKey.IsNullOrEmpty()) {
                    PublishTimerStart(eSpaceKey, publishStep, fromSS, developmentMode, traceKind, extraInfo, parentStep);
                    this.publishStep = publishStep;
                    this.eSpaceKey = eSpaceKey;
                    this.fromSS = fromSS;
                    this.developmentMode = developmentMode;
                    this.traceKind = traceKind;
                    this.extraInfo = extraInfo;
                    this.parentStep = parentStep;
                }
            }

            public void End() {
                if (!eSpaceKey.IsNullOrEmpty()) {
                    PublishTimerEnd(eSpaceKey, publishStep, fromSS, developmentMode, traceKind, extraInfo, parentStep);
                }
            }
        }

        public delegate TResult OSTraceFunc<TResult>();
        private static TraceSwitch logLevel = new TraceSwitch("LogLevel", "Entire Application");

        private static Dictionary<string, DateTime> ongoingTimers = new Dictionary<string, DateTime>();
        public static readonly int TimerFlushStartThreshold = 200;
        public static readonly TimeSpan TimerFlushTimeout = new TimeSpan(1, 0, 0); // 1 hour

        private static IPublishLog publishLog;
        public static IPublishLog PublishLog {
            get { return publishLog; }
            set { publishLog = value; }
        }

        private static void insertIntoListeners() {
            if (!System.Diagnostics.Debugger.IsAttached) {
                Trace.Listeners.Insert(0, new OSTraceListener());
            }
        }

        static OSTrace() {
            insertIntoListeners();
            Info("***** Starting log *****");
        }

        private static void FlushOldTimers() {
            Hashtable keysToKill = new Hashtable();
            string flushReport = "";

            lock (ongoingTimers) {
                foreach (var entry in ongoingTimers) {
                    if (DateTime.Now.Subtract(entry.Value) > TimerFlushTimeout) {
                        keysToKill.Add(entry.Key, null);
                    }
                }

                if (keysToKill.Count > 0) {
                    foreach (string key in keysToKill.Keys) {
                        flushReport += key + "\n";
                        ongoingTimers.Remove(key);
                    }

                    Debug(String.Format("The following old Timers were flushed:\n{0}", flushReport));
                }
            }
        }

        public static void Error(string format, params object[] args) {
            if (logLevel.TraceError) {
                Error(String.Format(format, args));
            }
        }

        public static void Error(string message) {
            if (logLevel.TraceError) {
                write(message, TraceCategory.ERROR);
            }
        }

        public static void Warning(string format, params object[] args) {
            if (logLevel.TraceWarning) {
                Warning(String.Format(format, args));
            }
        }

        public static void Warning(string message) {
            if (logLevel.TraceWarning) {
                write(message, TraceCategory.WARNING);
            }
        }

        public static void Info(string format, params object[] args) {
            if (logLevel.TraceInfo) {
                Info(String.Format(format, args));
            }
        }

        public static void Info(string message, params OSTraceFunc<string>[] extraMessages) {
            if (logLevel.TraceInfo) {
                foreach (OSTraceFunc<string> extra in extraMessages) {
                    message += extra();
                }
                Info(message);
            }
        }

        public static void Info(string message) {
            if (logLevel.TraceInfo) {
                write(message, TraceCategory.Info);
            }
        }

        public static void Debug(string format, params object[] args) {
            if (logLevel.TraceVerbose) {
                Debug(String.Format(format, args));
            }
        }

        public static void Debug(string message, params OSTraceFunc<string>[] extraMessages) {
            if (logLevel.TraceVerbose) {
                foreach (OSTraceFunc<string> extra in extraMessages) {
                    message += extra();
                }
                Debug(message);
            }
        }

        public static void Debug(Func<string> messageGetter) {
            if (logLevel.TraceVerbose) {
                Debug(messageGetter());
            }
        }

        public static void Debug(string message) {
            if (logLevel.TraceVerbose) {
                write(message, TraceCategory.Debug);
            }
        }

        public static void TimerStart(string timerName) {
            if (TimersActivated) {
                lock (ongoingTimers) {
                    if (ongoingTimers.ContainsKey(timerName)) {
                        Debug(String.Format("TimerStart '{0}' called again without first calling TimerEnd", timerName));
                    }
                    ongoingTimers[timerName] = DateTime.Now;
                    write(String.Format("Timer '{0}' started", timerName), TraceCategory.TimerStart);

                    // When a timer ends it gets deleted, so really OngoingTimers should only have ongoing entries in it
                    // Should there be a bug somewhere (Starts w/o Ends) we start throwing away old ones after they stack up
                    if (ongoingTimers.Count > TimerFlushStartThreshold) {
                        FlushOldTimers();
                    }
                }
            }
        }

        public static void TimerStart(string format, params object[] args) {
            if (TimersActivated) {
                TimerStart(String.Format(format, args));
            }
        }

        public static TimerObject Timer(string timerName) {
            return new TimerObject(timerName);
        }

        public static TimerObject Timer(string format, params object[] args) {
            return Timer(String.Format(format, args));
        }

        public static void TimerEnd(string timerName) {
            if (TimersActivated) {
                string message = String.Format("Timer '{0}' ended", timerName);

                lock (ongoingTimers) {
                    if (ongoingTimers.ContainsKey(timerName)) {
                        TimeSpan ts = DateTime.Now.Subtract(ongoingTimers[timerName]);
                        message += " (duration:" + ts.TotalMilliseconds + "ms -> ";
                        if (ts.Days > 0) {
                            // The first "" is needed for JAVA translation
                            message += "" + ts.Days + " days, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0) {
                            // The first "" is needed for JAVA translation
                            message += "" + ts.Hours + " hours, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0 || ts.Minutes > 0) {
                            // The first "" is needed for JAVA translation
                            message += "" + ts.Minutes + " minutes, ";
                        }
                        if (ts.Days > 0 || ts.Hours > 0 || ts.Minutes > 0 || ts.Seconds > 0) {
                            // The first "" is needed for JAVA translation
                            message += "" + ts.Seconds + " seconds and ";
                        }

                        // The first "" is needed for JAVA translation
                        message += "" + ts.Milliseconds + " miliseconds)";

                        ongoingTimers.Remove(timerName);
                    } else {
                        Debug(String.Format("TimerEnd '{0}' called without first calling TimerStart", timerName));
                    }
                }
                write(message, TraceCategory.TimerEnd);
            }
        }

        public static void TimerEnd(string format, params object[] args) {
            if (TimersActivated) {
                TimerEnd(String.Format(format, args));
            }
        }

        public enum TraceKind { OneClickPublish = 1, PageLoad = 2 }

        public static void PageLoadTimerStart(string eSpaceKey, string publishStep) {
            PublishTimerStart(eSpaceKey, publishStep, /*fromSS*/true, /*developmentMode*/true, TraceKind.PageLoad, /*extraInfo*/"", /*parentStep*/"");
        }

        public static void PublishTimerStart(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, TraceKind traceKind, string extraInfo, string parentStep) {
            if (TimersActivated) {
                TimerStart(publishStep);
            }
            if (CanLogPublishTrace(fromSS, developmentMode)) {
                DateTime currentDateTime = DateTime.Now;
                int milliseconds = currentDateTime.Millisecond;
                currentDateTime = new DateTime(currentDateTime.Year, currentDateTime.Month, currentDateTime.Day, currentDateTime.Hour, currentDateTime.Minute,
                    currentDateTime.Second);
                PublishLog.LogPublishTrace(currentDateTime, milliseconds, eSpaceKey, publishStep, /*isStart*/true, (int)traceKind, extraInfo, parentStep);
            }
        }

        public static void PageLoadTimerEnd(string eSpaceKey, string publishStep) {
            PublishTimerEnd(eSpaceKey, publishStep, /*fromSS*/true, /*developmentMode*/true, TraceKind.PageLoad, /*extraInfo*/"", /*parentStep*/"");
        }

        public static void PublishTimerEnd(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, TraceKind traceKind, string extraInfo, string parentStep) {
            if (TimersActivated) {
                TimerEnd(publishStep);
            }
            if (CanLogPublishTrace(fromSS, developmentMode)) {
                DateTime currentDateTime = DateTime.Now;
                int milliseconds = currentDateTime.Millisecond;
                currentDateTime = new DateTime(currentDateTime.Year, currentDateTime.Month, currentDateTime.Day, currentDateTime.Hour, currentDateTime.Minute,
                    currentDateTime.Second);
                PublishLog.LogPublishTrace(currentDateTime, milliseconds, eSpaceKey, publishStep, /*isStart*/false, (int)traceKind, extraInfo, parentStep);
            }
        }

        private static bool CanLogPublishTrace(bool fromSS, bool developmentMode) {
            return fromSS && developmentMode && PublishLog != null;
        }

        public static PublishTimerObject PublishTimer(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, string parentStep) {
            return new PublishTimerObject(eSpaceKey, publishStep, fromSS, developmentMode, TraceKind.OneClickPublish, /*extraInfo*/"", parentStep);
        }

        public static PublishTimerObject PublishTimer(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, string extraInfo, string parentStep) {
            return new PublishTimerObject(eSpaceKey, publishStep, fromSS, developmentMode, TraceKind.OneClickPublish, extraInfo, parentStep);
        }

        public static PublishTimerObject PublishTimer(string eSpaceKey, string publishStep, bool fromSS, bool developmentMode, TraceKind traceKind) {
            return new PublishTimerObject(eSpaceKey, publishStep, fromSS, developmentMode, traceKind, /*extraInfo*/"", /*parentStep*/"");
        }

        public static void Exception(System.Exception e) {
            if (logLevel.TraceError) {
                ExceptionInternal(e, null);
            }
        }

        public static void InfoException(System.Exception e, string taskDescription) {
            if (logLevel.TraceInfo) {
                ExceptionInternal(e, taskDescription);
            }
        }

        public static void Exception(System.Exception e, string taskDescription) {
            if (logLevel.TraceError) {
                ExceptionInternal(e, taskDescription);
            }
        }

        public static void Exception(System.Exception e, string format, params object[] args) {
            if (logLevel.TraceError) {
                ExceptionInternal(e, String.Format(format, args));
            }
        }

        private static void ExceptionInternal(System.Exception e, string taskDescription) {
            
            string errorString = e.Message + "\n" + ExceptionUtils.GetExceptionStack(e);
            errorString = errorString.Replace("\n", "\n\t");
            if (!string.IsNullOrEmpty(taskDescription)) {
                errorString = taskDescription + "\n" + errorString;
            }
            write(errorString, TraceCategory.ERROR);
        }

        public static void Data(string data) {
            if (logLevel.TraceVerbose) {
                write(data, TraceCategory.Data);
            }
        }

        public static void Data(string format, params object[] args) {
            if (logLevel.TraceVerbose) {
                Data(String.Format(format, args));
            }
        }

        public static TraceSwitch getRealLogLevel() {
            return logLevel;
        }

        public static void setRealLogLevel(TraceLevel newLevel) {
            logLevel.Level = newLevel;
        }

        private static void writeLine(string message, TraceCategory category) {
#pragma warning disable 0618
            Trace.WriteLine(String.Format("{0} [{3}] [{1}] {2}",
                DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffff"),
                category.ToString(),
                message,
                AppDomain.GetCurrentThreadId()));
#pragma warning restore 0618
        }

        private static void writeLine(string[] messages, TraceCategory category) {
            foreach (string message in messages) {
                writeLine(message, category);
            }
        }

        private static void write(string message, TraceCategory category) {
            if (message.Contains("\n")) {
                message = message.Replace("\r\n", "\n");
                string[] lines = message.Split('\n');
                writeLine(lines, category);
            } else {
                writeLine(message, category);
            }
        }

        /// <summary>
        /// Auxiliar listener that converts a Fail into an exception.
        /// </summary>
        private class OSTraceListener : DefaultTraceListener {
            public override void Fail(string message, string detailMessage) {
                //Do not call here base.fail (that will cause a popup on server side / leave a compiler process hanged - eternal concurrent publishing)
                throw new HEMessageException(new HEMessage("OSTraceFail", "Internal Error", string.Format("Internal trace failure: {0}.", message), 2063, "", HEMessageType.Error, true));
            }
        }

        public static bool TimersActivated { get { return logLevel.TraceVerbose; } }

        public static void SetLogLevel(TraceLevel level) {
            if (level == TraceLevel.Off) {
                Info("Trace Level turned off");
            }
            logLevel.Level = level;
            if (level != TraceLevel.Off) {
                Info("Trace Level set to " + level);
            }
        }
    }
}
