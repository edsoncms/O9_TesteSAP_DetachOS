/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using System.Reflection;
using System.Web;
using System.IO;
using System.Web.Hosting;
using System.ComponentModel;

namespace OutSystems.HubEdition.RuntimePlatform {

    public interface IForeignServiceProxy : IContainer {
        AppDomain ServiceDomain { get; }
        void SetUp();
        void LoadState(ForeignApplicationHostedService.State state);
        void ExecuteService();
    }

    public abstract class ForeignApplicationHostedService : MarshalByRefObject, IForeignServiceProxy {

        private string _applicationName;

        public ForeignApplicationHostedService() {
            if (this.GetType().GetConstructor(new Type[] {}) == null) {
                // A default constructor is required
                throw new InvalidOperationException("Parameterless constructor not found");
            }
        }

        public ForeignApplicationHostedService(string applicationName) : this() {
            _applicationName = applicationName;
        }

        private string ApplicationVirtualPath { get { return "/" + _applicationName; } }

        public void SetUp() {
            // Disable file changes monitoring. This mechanism could trigger the AppDomain unload at any moment
            PropertyInfo fileChangesMonitorProperty = typeof(HttpRuntime).GetProperty("FileChangesMonitor", BindingFlags.Static | BindingFlags.NonPublic);
            object fileChangesMonitor = fileChangesMonitorProperty.GetValue(null, null);
            MethodInfo stopMethod = fileChangesMonitor.GetType().GetMethod("Stop", BindingFlags.Instance | BindingFlags.NonPublic);
            stopMethod.Invoke(fileChangesMonitor, new object[] {});
        }

        public void Invoke() {
            IForeignServiceProxy proxy = CreateForeignServiceProxy();
            AppDomain domain = proxy.ServiceDomain;
            try {
                proxy.SetUp();
                proxy.LoadState(this.SaveState());
                Invoke(proxy);
            } finally {
                AppDomain.Unload(domain);
            }
        }

        protected virtual void Invoke(IForeignServiceProxy proxy) {
            proxy.ExecuteService();
        }

        protected virtual IForeignServiceProxy CreateForeignServiceProxy() {
            string physicalProviderPath = HostingEnvironment.MapPath(ApplicationVirtualPath) + @"\";

            // The type passed to CreateApplicationHost *must* be in an assembly in GAC, so we use the Component class
            // and later on serialize objects to the new AppDomain through it
            Component host = (Component) ApplicationHost.CreateApplicationHost(typeof(Component), ApplicationVirtualPath, physicalProviderPath);

            // Retrieve by-reference the Container object.
            // This object will be created in the foreign AppDomain, and marshalled back by-reference.
            // We will end up with a transparent proxy to the foreign object.
            host.Site = new ApplicationHostTypeLoaderProxy(this);
            return (IForeignServiceProxy) host.Container;
        }

        #region IContainer Members

        void IContainer.Add(IComponent component, string name) { }
        void IContainer.Add(IComponent component) { }
        ComponentCollection IContainer.Components { get { return new ComponentCollection(new IComponent[] {}); } }
        void IContainer.Remove(IComponent component) { }
        void IDisposable.Dispose() { }

        #endregion

        public abstract State SaveState();
        public abstract void LoadState(State state);
        
        public AppDomain ServiceDomain { get { return AppDomain.CurrentDomain; } }

        protected virtual string Page { get { return string.Empty; } }
        protected virtual string Query { get { return string.Empty; } }
        protected virtual TextWriter GetResponseWriter() { return TextWriter.Null; }

        public virtual void ExecuteService() {
            TextWriter responseWriter = GetResponseWriter();
            HttpWorkerRequest worker = new SimpleWorkerRequest(Page, Query, responseWriter);
            HttpContext context = new HttpContext(worker);

            Type httpApplicationFactory = typeof(HttpApplication).Assembly.GetType("System.Web.HttpApplicationFactory");
            MethodInfo getApplicationInstance = httpApplicationFactory.GetMethod("GetApplicationInstance", BindingFlags.Static | BindingFlags.NonPublic);
            FieldInfo httpApplicationContextField = typeof(HttpApplication).GetField("_context", BindingFlags.Instance | BindingFlags.NonPublic);

            /* Initialize HttpApplication */
            HttpApplication applicationInstance = getApplicationInstance.Invoke(null, new object[] { context }) as HttpApplication;
            context.ApplicationInstance = applicationInstance;

            HttpContext oldContext = HttpContext.Current;
            HttpContext.Current = context;
            httpApplicationContextField.SetValue(applicationInstance, context);
            try {
                MethodInfo beginRequest = applicationInstance.GetType().GetMethod("Application_BeginRequest", BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(object), typeof(EventArgs) }, null);
                if (beginRequest != null) {
                    beginRequest.Invoke(applicationInstance, new object[] { applicationInstance, EventArgs.Empty });
                }

                ExecuteService(context);

                MethodInfo endRequest = applicationInstance.GetType().GetMethod("Application_EndRequest", BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { typeof(object), typeof(EventArgs) }, null);
                if (endRequest != null) {
                    endRequest.Invoke(applicationInstance, new object[] { applicationInstance, EventArgs.Empty });
                }
            } finally {
                HttpContext.Current = oldContext;
                httpApplicationContextField.SetValue(applicationInstance, null);
            }
        }

        protected virtual void ExecuteService(HttpContext context) {
        }


        [Serializable]
        public abstract class State {
        }

        [Serializable]
        private class ApplicationHostTypeLoaderProxy : ISite {

            private AssemblyName _assemblyName;
            private string _typeName;

            public ApplicationHostTypeLoaderProxy(ForeignApplicationHostedService service) {
                _assemblyName = service.GetType().Assembly.GetName();
                _typeName = service.GetType().FullName;
            }

            private Assembly _assembly;

            public virtual IContainer Container {
                get {
                    AppDomain.CurrentDomain.AssemblyResolve += AssemblyResolve;
                    _assembly = Assembly.Load(_assemblyName);
                    Type type = _assembly.GetType(_typeName);
                    ForeignApplicationHostedService obj = (ForeignApplicationHostedService) type.GetConstructor(new Type[] {}).Invoke(new object[] {});
                    return obj;
                }
            }

            private Assembly AssemblyResolve(object sender, ResolveEventArgs args) {
                if (args.Name == _assemblyName.Name) {
                    return _assembly;
                } else {
                    return null;
                }
            }

            #region ISite Members

            public object GetService(Type serviceType) { return null; }
            public IComponent Component { get { return null; } }
            public bool DesignMode { get { return false; } }
            public string Name { get { return string.Empty; } set { } }

            #endregion
        }

    }

}