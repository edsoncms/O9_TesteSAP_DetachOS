/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using OutSystems.HubEdition.RuntimePlatform.MetaInformation;
using OutSystems.RuntimeCommon;
using OutSystems.HubEdition.RuntimePlatform.Db;
using System.Data;
using OutSystems.ObjectKeys;
using OutSystems.Internal.Db;

namespace OutSystems.HubEdition.RuntimePlatform.Log {

    [Serializable()]
    public class CustomLog {

        [Serializable()]
        public class CustomLogField {
            public object Value;
            public bool IsEntityReference;
            public bool IsMandatory;

            public CustomLogField(object value, bool isEntityReference, bool isMandatory) {
                Value = value;
                IsEntityReference = isEntityReference;
                IsMandatory = isMandatory;
            }
        }

        private readonly string entityName;
        private readonly int entityGeneration;
        private readonly string physicalTableName;
        private readonly string dbConnection;
        private readonly string dbCatalog;
        public readonly Hashtable Fields;

        private static IDictionary<string, int> catalogCache = new Dictionary<string, int>();

        internal CustomLog(string entityName, string physicalTableName, int entityGeneration, string dbConnection, string dbCatalog) {
            this.entityName = entityName;
            this.physicalTableName = physicalTableName;
            this.entityGeneration = entityGeneration;
            this.dbConnection = dbConnection;
            this.dbCatalog = dbCatalog;
            Fields = new Hashtable(50);
        }

        public string PhysicalTableName {
            get { return physicalTableName; }
        }

        public string EntityName {
            get { return entityName; }
        }

        public int EntityGeneration {
            get { return entityGeneration; }
        }

        public string DBConnection {
            get { return dbConnection; }
        }

        public string DbCatalog {
            get { return dbCatalog; }
        }

        private bool LogAsynchronousEnabled {
            get {
                return RuntimeLogger.LogAsynchronousEnabled;
            }
        }

        private string GenerateTableKey() {
            return PhysicalTableName + "." + EntityGeneration;
        }

        public CustomLog(object ssRecord) {

            if (ssRecord is IRecord) {
                // Record inspection:
                // - get structure field from record
                // - get its EntityRecordDetails attribute
                // - there must be a single structure in the record (this is an entity record and not a recordjoin)

                var entAttr = ssRecord.GetType().GetFields(BindingFlags.Public | BindingFlags.Instance)
                                       .Select(
                                           field =>
                                               new {
                                                   Field = field,
                                                   EntityDetails = field.FieldType.GetCustomAttributes(typeof(EntityRecordDetails), false).FirstOrDefault()
                                               })
                                       .Where(fa => fa.EntityDetails != null)
                                       .FirstIfSingleOrDefault();

                if (entAttr != null) {

                    var entityDetails = (EntityRecordDetails)entAttr.EntityDetails;

                    //var entityRecordAttributes = (Attribute[])structAttrs[0].FieldType.GetCustomAttributes(typeof(EntityRecordDetails), false);
                    //if (entityRecordAttributes.Length == 1) {
                    //EntityRecordDetails entityDetails = (EntityRecordDetails) entityRecordAttributes[0];

                    entityName = entityDetails.Name;
                    entityGeneration = entityDetails.Generation;
                    physicalTableName = entityDetails.PhysicalTableName;
                    dbConnection = entityDetails.DBConnection;

                    ssRecord = entAttr.Field.GetValue(ssRecord);
                    var structAttrs = ssRecord.GetType().GetFields(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);

                    int eSpaceId;
                    if (!catalogCache.TryGetValue(entityDetails.OwnerKey, out eSpaceId)) {
                        using (Transaction transaction = DatabaseAccess.ForSystemDatabase.GetCommitableTransaction()) {
                            eSpaceId = DBRuntimePlatform.Instance.GetESpaceIdbyKey(transaction, ObjectKey.Parse(entityDetails.OwnerKey));
                        }

                        lock (catalogCache) {
                            int tmpESpaceId;
                            // try again for concurrency reasons
                            if (!catalogCache.TryGetValue(entityDetails.OwnerKey, out tmpESpaceId)) {
                                catalogCache.Add(entityDetails.OwnerKey, eSpaceId);
                            }
                        }
                    }

                    // This method uses also cache
                    dbCatalog = DatabaseAccess.ForEspaceDatabase(eSpaceId).DatabaseServices.DatabaseConfiguration.DatabaseIdentifier;

                    Fields = new Hashtable(10);

                    for (int i = 0; i < structAttrs.Length; i++) {
                        var attrs = (Attribute[])structAttrs[i].GetCustomAttributes(typeof(EntityAttributeDetails), false);
                        if (attrs.Length == 1) {
                            EntityAttributeDetails entityAttributeDetails = (EntityAttributeDetails)attrs[0];
                            if (!entityAttributeDetails.IsAutonumber) {
                                var customLogField = new CustomLogField(structAttrs[i].GetValue(ssRecord), entityAttributeDetails.IsEntityReference, entityAttributeDetails.IsMandatory);
                                Fields.Add(entityAttributeDetails.Name, customLogField);
                            }

                        }
                    }
                    return;
                }
            }

            throw new InvalidCastException("Unable to convert to record");
        }

        public static void Write(CustomLog log) {
            Write(new List<CustomLog>() { log });
        }

        public static void Write(List<CustomLog> logList) {
           IEnumerable<DataTable> tables = ConvertToDataTable(logList);
           foreach (CustomLogDataTable tab in tables) {
               if (!tab.DbConnection.IsEmpty()) {
                   DatabaseAccess.ForDBConnection(tab.DbConnection).DatabaseServices.ExecutionService.BulkInsert(tab);
               } else if (DatabaseAccess.ForSystemDatabase.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier == tab.DbCatalog) {
                   DatabaseAccess.ForSystemDatabase.DatabaseServices.ExecutionService.BulkInsert(tab);
               } else {
                   DatabaseAccess.ForDatabase(tab.DbCatalog).DatabaseServices.ExecutionService.BulkInsert(tab); 
               }
           }
        }

        public static DataTable ConvertToDataTable(CustomLog log) {
            return ConvertToDataTable(new List<CustomLog>() { log }).FirstOrDefault();
        }

        public static IEnumerable<DataTable> ConvertToDataTable(List<CustomLog> logList) {
            // Aggregate by message kind
            var tables = new Dictionary<string, CustomLogDataTable>();

            foreach (CustomLog log in logList) {
                var key = log.GenerateTableKey();

                CustomLogDataTable table;
                if (!tables.TryGetValue(key, out table)) {
                    table = new CustomLogDataTable(log.PhysicalTableName) {
                        DbConnection = log.DBConnection,
                        DbCatalog = log.DbCatalog,
                    };

                    foreach (DictionaryEntry field in log.Fields) {
                        object valueAux = null;
                        if (field.Value is CustomLog.CustomLogField) {
                            valueAux = ((CustomLog.CustomLogField)field.Value).Value;
                        } else {
                            valueAux = field.Value;
                        }
                        table.Columns.Add((string)field.Key, valueAux.GetType());
                    }

                    tables.Add(key, table);
                }

                var row = table.NewRow();
                foreach (DictionaryEntry attribute in log.Fields) {
                    object valueAux = null;
                    //#1026097 - When the entity attribute is an EntityReference, is not mandatory and its value is '0'
                    //replace the value by a BDNULL to avoid hitting the foreign key constraint.
                    if (attribute.Value is CustomLog.CustomLogField) {
                        var customLogField = (CustomLog.CustomLogField)attribute.Value;
                        if (customLogField.IsEntityReference && !customLogField.IsMandatory && customLogField.Value.Equals(0)) {
                            valueAux = DBNull.Value;
                        } else {
                            valueAux = customLogField.Value;
                        }
                    } else {
                        valueAux = attribute.Value;
                    }
                    row[(string)attribute.Key] = valueAux;
                }
                table.Rows.Add(row);
            }

            return tables.Values.Cast<DataTable>();
        }

        private sealed class CustomLogDataTable : DataTable {
            public string DbConnection { get; set; }
            public string DbCatalog { get; set; }
            public CustomLogDataTable(string physicalTableName)
                : base(physicalTableName) {
            }
        }

    }

}
