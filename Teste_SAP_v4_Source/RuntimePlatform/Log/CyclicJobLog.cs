/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;

namespace OutSystems.HubEdition.RuntimePlatform.Log {
    [Serializable()]
    public class CyclicJobLog : ICloneable {
        // TODO : Create readonly accessor function for this batch of variables
        public DateTime Instant;
        public int Duration;
        public ObjectKey CyclicJobKey;
        public int EspaceId;
        public int TenantId;
        public string ExecutedBy;
        public string ErrorId;
        public DateTime ShouldHaveRunAt;
        public DateTime NextRun;
        public string RequestKey;
        // END OF TODO

        [NonSerialized()]
        private Action<CyclicJobLog> logger = log => RuntimeLogger.Log(log);
       
        public const int MAX_EXECUTED_BY_SIZE = 50;
        public const int MAX_ERROR_ID_SIZE = 50;

        public CyclicJobLog() {
        }

        public CyclicJobLog(DateTime instant, int duration, ObjectKey cyclicJobKey, int espaceId, int tenantId, string executedBy, string errorId, DateTime shouldHaveRunAt, DateTime nextRun) {
            Instant = instant;
            Duration = duration;
            CyclicJobKey = cyclicJobKey;
            EspaceId = espaceId;
            TenantId = tenantId;
            ExecutedBy = executedBy;
            ErrorId = errorId;
            ShouldHaveRunAt = shouldHaveRunAt;
            NextRun = nextRun;

            RequestTracer reqTracer = RuntimePlatformUtils.GetRequestTracer();
            if (reqTracer != null) {
                RequestKey = reqTracer.RequestKey;
            }
        }

        public CyclicJobLog(CyclicJobLog obj) {
            Instant = obj.Instant;
            Duration = obj.Duration;
            CyclicJobKey = obj.CyclicJobKey;
            EspaceId = obj.EspaceId;
            TenantId = obj.TenantId;
            ExecutedBy = obj.ExecutedBy;
            ErrorId = obj.ErrorId;
            ShouldHaveRunAt = obj.ShouldHaveRunAt;
            NextRun = obj.NextRun;
            RequestKey = obj.RequestKey;
        }

        public object Clone() {
            return new CyclicJobLog(this);
        }

        public static void StaticWrite(
                        DateTime instant,
            int duration,
            ObjectKey cyclicJobKey,
            int espaceId,
            int tenantId,
            string executedBy,
            string errorId,
            DateTime shouldHaveRunAt,
            DateTime nextRun) {
            CyclicJobLog log = new CyclicJobLog();
            log.Write(instant, duration, cyclicJobKey, espaceId, tenantId, executedBy, errorId, shouldHaveRunAt, nextRun);
        }

        public void Write(
            DateTime instant,
            int duration,
            ObjectKey cyclicJobKey,
            int espaceId,
            int tenantId,
            string executedBy,
            string errorId,
            DateTime shouldHaveRunAt,
            DateTime nextRun) {
            Instant = instant;
            Duration = duration;
            CyclicJobKey = cyclicJobKey;
            EspaceId = espaceId;
            TenantId = tenantId;
            ExecutedBy = executedBy;
            ErrorId = errorId;
            ShouldHaveRunAt = shouldHaveRunAt;
            NextRun = nextRun;

            RequestTracer reqTracer = RuntimePlatformUtils.GetRequestTracer();
            if (reqTracer != null) {
                RequestKey = reqTracer.RequestKey;
            }
            logger(this);
        }

        public void LogTo(Action<CyclicJobLog> logger) {
            this.logger = logger;
        }
    }
}
