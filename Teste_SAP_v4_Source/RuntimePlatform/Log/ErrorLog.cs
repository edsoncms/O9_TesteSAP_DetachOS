/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Diagnostics;
using System.Reflection;
using System.Threading;
using System.Web;
using OutSystems.RuntimeCommon;
using System.Collections;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using System.Text;

namespace OutSystems.HubEdition.RuntimePlatform.Log {
    [Serializable()]
    public class ErrorLog : ICloneable {
        // TODO : Create readonly accessor function for this batch of variables
        public string Id;
        public DateTime Instant;
        public string SessionId;
        public int EspaceId;
        public int TenantId;
        public int UserId;
        public string Message;
        public string Stack;
        public string ModuleName;
        public string Server;
        public string EnvironmentInformation;
        public string RequestKey;
        public string EntrypointName;
        public string ActionName;
        // END OF TODO


        [NonSerialized()]
        private Action<ErrorLog, bool> logger = (log, forceSynchronous) => RuntimeLogger.Log(log, forceSynchronous);

        internal static string EnvironmentInformationOverride {
            [DoNotObfuscate]
            private get;
            [DoNotObfuscate]
            set;
        }

        public const int MAX_STACK_SIZE = 500000;
        public const int MAX_ENVIRONMENT_INFORMATION_SIZE = 2000;
        private const int MAX_INNER_EXCEPTION_DEPTH = 10;
        public const int MAX_ID_SIZE = 50;
        public const int MAX_SESSION_ID_SIZE = 50;
        public const int MAX_MESSAGE_SIZE = 2000;
        public const int MAX_MODULE_NAME_SIZE = 15;
        public const int MAX_SERVER_SIZE = 50;
        public const int MAX_ACTION_NAME = 50;
        public const int THRESHOLD_STACK_SIZE_FLUSH = 100000;

        public ErrorLog() {
        }

        public ErrorLog(string id, DateTime instant, string sessionId, int espaceId, int tenantId, int userId, string message, string stack, string moduleName, string server) {
            Id = id;
            Instant = instant;
            SessionId = sessionId;
            EspaceId = espaceId;
            TenantId = tenantId;
            UserId = userId;
            Message = message;
            Stack = stack;
            ModuleName = moduleName;
            Server = server;
        }

        public ErrorLog(ErrorLog obj) {
            Id = Guid.NewGuid().ToString();
            Instant = obj.Instant;
            SessionId = obj.SessionId;
            EspaceId = obj.EspaceId;
            TenantId = obj.TenantId;
            UserId = obj.UserId;
            Message = obj.Message;
            Stack = obj.Stack;
            ModuleName = obj.ModuleName;
            Server = obj.Server;
            RequestKey = obj.RequestKey;
            ActionName = obj.ActionName;
            EntrypointName = obj.EntrypointName;
        }

        public object Clone() {
            return new ErrorLog(this);
        }

        public static string StaticWrite(DateTime instant, string sessionId, int espaceId, int tenantId, int userId, string message, 
                string stack, string moduleName) {

            return StaticWrite(instant, sessionId, espaceId, tenantId, userId, message, stack, moduleName, false);
        }

        public static string StaticWrite(DateTime instant, string sessionId, int espaceId, int tenantId, int userId, string message,
            string stack, string environmentInformation, string moduleName) {

            ErrorLog log = new ErrorLog();
            log.Write(GenerateLogId(), instant, sessionId, espaceId, tenantId, userId, message, stack, environmentInformation, moduleName, false);
            return log.ErrorId; 
            
        }

        public static string StaticSynchronousWrite(DateTime instant, string sessionId, int espaceId, int tenantId, int userId, string message, 
                string stack, string moduleName) {

            return StaticWrite(instant, sessionId, espaceId, tenantId, userId, message, stack, moduleName, true);
        }

        private static string StaticWrite(DateTime instant, string sessionId, int espaceId, int tenantId, int userId, string message, 
                string stack, string moduleName, bool forceSynchronous) {

            ErrorLog log = new ErrorLog();
            log.Write(GenerateLogId(), instant, sessionId, espaceId, tenantId, userId, message, stack, /* environmentInformation */ null, moduleName, forceSynchronous);
            return log.ErrorId;
        }

        private static string GenerateLogId() {
            return Guid.NewGuid().ToString();
        }

        public void LogTo(Action<ErrorLog,bool> logger) {
            this.logger = logger;
        }

        private static string StaticWriteWithId(
            string id,
            DateTime instant,
            string sessionId,
            int espaceId,
            int tenantId,
            int userId,
            string message,
            string stack,
            string environmentInformation,
            string moduleName,
            string requestKey,
            string entrypointName,
            string actionName) 
        {
            ErrorLog log = new ErrorLog();
            log.Write(id, instant, sessionId, espaceId, tenantId, userId, message, stack, environmentInformation, moduleName, requestKey, entrypointName, actionName, false);
            return log.ErrorId;
        }

        public void Write(
           string id,
           DateTime instant,
           string sessionId,
           int espaceId,
           int tenantId,
           int userId,
           string message,
           string stack,
           string environmentInformation,
           string moduleName,
           string requestKey,
           string entrypointName,
           string actionName,
           bool forceSynchronous)
        {
            Id = id;
            Instant = instant;
            SessionId = sessionId;
            EspaceId = espaceId;
            TenantId = tenantId;
            UserId = userId;
            Message = Truncate(message, MAX_MESSAGE_SIZE);
            Stack = Truncate(stack, MAX_STACK_SIZE);
            ModuleName = moduleName;
            Server = Environment.MachineName;
            EnvironmentInformation = Truncate(environmentInformation, MAX_ENVIRONMENT_INFORMATION_SIZE);
            RequestKey = requestKey;
            EntrypointName = entrypointName;
            ActionName = actionName;

            logger(this, forceSynchronous);
        }

        private void Write(
            string id,
            DateTime instant,
            string sessionId,
            int espaceId,
            int tenantId,
            int userId,
            string message,
            string stack,
            string environmentInformation,
            string moduleName, 
            bool forceSynchronous) 
        {
            Write(id, instant, sessionId, espaceId, tenantId, userId, message, stack, environmentInformation, moduleName, "", "", "", forceSynchronous);
        }

        private string Truncate(string str, int maxSize) {
            if (!str.IsEmpty()) {
                if (str.Length > maxSize) {
                    // Safe fallback - truncate the information, can't afford space for it
                    str = str.Substring(0, maxSize - 3) + "...";
                }
                return str;
            }

            return string.Empty;
        }

        public string ErrorId {
            get {
                if (Id == null || Id == "") {
                    return "";
                } else {
                    return Id;
                }
            }
        }

        public static string LogApplicationError(Exception excep, AppInfo info, HeContext context, string moduleName) {
            return LogApplicationError(DateTime.Now, excep.Message, excep, info, context, moduleName, null, -1, -1);
        }

        public static string LogApplicationError(Exception excep, HeContext context, string moduleName) {
            return LogApplicationError(DateTime.Now, excep.Message, excep, /*AppInfo*/null, context, moduleName, null, -1, -1);
        }

        public static string LogApplicationError(int espaceId, int tenantId, string message, Exception excep, HeContext context, string moduleName) {
            return LogApplicationError(DateTime.Now, message, excep, /*AppInfo*/null, context, moduleName, null, espaceId, tenantId);
        }
        
        public static string LogApplicationError(string message, string stackTrace, HeContext context, string moduleName) {
            return LogApplicationError(DateTime.Now, message, null, /*AppInfo*/null, context, moduleName, stackTrace, -1, -1);
        }

        public static string LogApplicationError(int espaceId, int tenantId, string message, string stackTrace, HeContext context, string moduleName) {
            return LogApplicationError(DateTime.Now, message, null, /*AppInfo*/null, context, moduleName, stackTrace, espaceId, tenantId);
        }

        public static string LogApplicationError(DateTime instant, Exception excep, HeContext context, string moduleName) {
            return LogApplicationError(instant, excep.Message, excep, /*AppInfo*/null, context, moduleName, null, -1, -1);
        }

        /* Recursive call counter (#534214)*/
        [ThreadStatic]
        private static int visitsApplicationErrorLog = 0;

        public static void ClearApplicationErrorLogVisits() {            
        }

        //[DebuggerNonUserCode]
        private static string LogApplicationError(DateTime instant, string message, Exception excep, AppInfo info, HeContext context, string moduleName,
                string stackTrace, int overrideEspaceId, int overrideTenantId) {

            visitsApplicationErrorLog = visitsApplicationErrorLog+1;
            try {
                string errorId = "", sessionid = "", requestKey = "", actionName = "", entrypointName = "";
                int espaceid = 0, tenantid = 0, userid = 0;

                /* Prevent recursive loop attempt (#534214).
                 * 1st attempt tries to get info for logging (visitsApplicationErrorLog=1)
                 * 2nd attempt tries to log the new exception without getting info for logging (visitsApplicationErrorLog=2)
                 * 3rd attempt don't log the new exception to avoid recursive loops (visitsApplicationErrorLog>=3 */

                if (visitsApplicationErrorLog >= 3) {
                    return "";
                }

                if (visitsApplicationErrorLog < 2) {
                    try { info = info ?? AppInfo.GetAppInfo(); }
                    catch { }

                    if (info != null) {
                        try { espaceid = info.eSpaceId; } catch { }
                        try { tenantid = info.Tenant.Id; } catch { }

                    }

                    espaceid = overrideEspaceId != -1 ? overrideEspaceId : espaceid;
                    tenantid = overrideTenantId != -1 ? overrideTenantId : tenantid;

                    if (context != null) {
                        try { sessionid = context.Session.SessionID; }
                        catch { }
                        try { userid = context.Session.UserId; }
                        catch { }

                        if (context.RequestTracer != null)
                        {
                            RequestTracer requestTracer = context.RequestTracer;
                            requestKey = requestTracer.RequestKey;
                            actionName = requestTracer.EntryActionName;
                            entrypointName = requestTracer.EntryEndpointName;
                            requestTracer.RegisterError();
                        }
                    }
                }

                try {
                    if ((excep is HttpException) && ((excep.Message != null) && excep.Message.StartsWith("Error executing child request")) && (excep.InnerException != null)) {
                        excep = excep.InnerException;
                    }

                    if (stackTrace != null) {
                        stackTrace = stackTrace.Replace(Environment.NewLine, BuiltInFunction.NewLine());
                    }
                    
                    string environmentInformation = GetStackEnvironmentInfo(info, context);
                    string extraDetailMessage = "";

                    // try to generate full stack of the exception to see if we can fit all inner exceptions in a single error entry
                    int countExceptions = 1;
                    if (excep != null && excep.InnerException != null) {
                        stackTrace = GenerateFullStack(excep, out countExceptions);
                    }

                    errorId = GenerateLogId();
                    StringBuilder stack = new StringBuilder();

                    // create an error message dumping MAX_INNER_EXCEPTION_DEPTH inner exceptions if no stactTrace is provided
                    int maxretries = (stackTrace != null) ? 1 : MAX_INNER_EXCEPTION_DEPTH;
                    while ((excep != null && maxretries-- > 0) || stackTrace != null) {
                        extraDetailMessage = string.Empty;
                        if (stackTrace != null) {
                            stack.Append(stackTrace); // if we are given the stacktrace as a whole, assume the message is also set or included
                            stackTrace = null;
                        } else if (excep.StackTrace != null) {
                            if (message.IsEmpty()) {
                                message = excep.Message ?? string.Empty;
                            } else if (!RuntimePlatformUtils.IsJava() && excep != null && excep.Message != null && !message.Contains(excep.Message)) {
                                extraDetailMessage = excep.Message + BuiltInFunction.NewLine();
                            } else if (RuntimePlatformUtils.IsJava() && excep != null) {
                                extraDetailMessage = ExceptionMessageNormalized(excep);
                            }

                            if (!message.IsEmpty()) {
                                stack.AppendLine(message);
                            }

                            if (!extraDetailMessage.IsEmpty()) {
                                stack.AppendLine(extraDetailMessage);
                            }
                            
                            stack.Append(excep.StackTrace.Replace(Environment.NewLine, BuiltInFunction.NewLine()));                        
                        }

                        // advance to the next inner exception    
                        if (excep != null) {
                            excep = excep.InnerException;
                        }
                    }

                    // log dumped inner exceptions stack trace
                    ErrorLog.StaticWriteWithId(errorId, instant, sessionid, espaceid, tenantid, userid, message, stack.ToString(), environmentInformation, moduleName, requestKey, entrypointName, actionName);
                }
                catch (Exception writeErrorException) {
                    try {
                        ErrorLog.StaticWrite(DateTime.Now, sessionid, espaceid, tenantid, userid,
                                "Exception in Global.LogError:" + BuiltInFunction.NewLine() + writeErrorException.Message,
                                writeErrorException.StackTrace, "Global");
                    }
                    catch { }
                }
                return errorId;

            }
            finally {
                visitsApplicationErrorLog = visitsApplicationErrorLog-1;
            }
        }

        private static string ExceptionMessageNormalized(Exception excep) {
            if (RuntimePlatformUtils.IsJava()) {
                return excep.GetType().FullName + (excep.Message != null ? ": " + excep.Message : "");
            } else {
                return (excep.Message != null ? excep.Message : "");
            }
        }

        public static string GenerateFullStack(Exception excep, out int countExceptions) {
            string result = "";
            countExceptions = 0;
            bool hasInnerException = (excep.InnerException != null);

            int maxretries = MAX_INNER_EXCEPTION_DEPTH;
            while (excep != null && maxretries-- > 0) {
                result += (result.Length > 0 ? BuiltInFunction.NewLine() : "") +
                    (hasInnerException ? "[" + (countExceptions + 1) + "] " : "") + ExceptionMessageNormalized(excep) +
                    BuiltInFunction.NewLine() +  (!excep.StackTrace.IsNullOrEmpty() ? excep.StackTrace.Replace(Environment.NewLine, BuiltInFunction.NewLine()): "") + BuiltInFunction.NewLine();
                excep = excep.InnerException;
                countExceptions++;
            }
            return result;
        }

        //[DebuggerNonUserCode]
        public static string GetStackEnvironmentInfo(AppInfo info, HeContext context) {

            try { info = info ?? AppInfo.GetAppInfo(); } catch { }

            // safely get all environment parameters
            string requestUrl = "", requestMethod = "", requestQuery = "", applicationPath = "", processName = "", processStartTime = "", currentLocale = "", filePath = "", dateFormat = "", dotNetVersion = "", appDomain = "", compiledWithVersion = "";
            int espaceVersionId = 0, espaceVersion = 0, espaceVersionPublishingId = 0, processId = 0;
            long privateMBytes = 0, virtualMBytes = 0, threadId = 0;
            string threadName = "";

            if (info != null) {
                try { espaceVersionId = info.eSpaceVersionId; } catch { }
                try { espaceVersion = info.eSpaceVersion; } catch { }
                try { espaceVersionPublishingId = info.eSpaceVersionPublishingId; } catch { }
            }
            if (context != null) {
                try { requestUrl = context.Context.Request.Url.ToString(); } catch { }
                try { requestMethod = context.Context.Request.HttpMethod; } catch { }
                try {
                    
                    requestQuery = context.Context.Request.QueryString != null ? context.Context.Request.QueryString.ToString() : "";
                } catch { }
                try { currentLocale = context.CurrentLocale; } catch { }
            }
            
            try {
                applicationPath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase;
                applicationPath = applicationPath.Replace("Program Files\\OutSystems\\Service Center", "...\\SC")
                                                 .Replace("Program Files\\OutSystems\\Platform Server", "...\\PS")
                                                 .Replace("Program Files\\OutSystems\\Hub Server", "...\\HS");
            } catch { }
            
            try { privateMBytes = Process.GetCurrentProcess().PrivateMemorySize64 / 1024 / 1024; } catch { }
            
            try { virtualMBytes = Process.GetCurrentProcess().VirtualMemorySize64 / 1024 / 1024; } catch { }
            
            try { processId = Process.GetCurrentProcess().Id; } catch { }
            
            try { processName = Process.GetCurrentProcess().ProcessName; } catch { }
            
            try { processStartTime = Process.GetCurrentProcess().StartTime.ToUniversalTime().ToString(); } catch { }
            try { threadId = Thread.CurrentThread.ManagedThreadId; } catch { }
            
            try { threadName = Thread.CurrentThread.Name; } catch { }
            try {
                if (context != null && context.CurrentExecutionFileName != null) {
                    filePath = BuiltInFunction.NewLine() + "FilePath: " + applicationPath + context.CurrentExecutionFileName;
                }
            } catch { }
            try { dateFormat = FormatInfo.GetOutputDateFormatString(); } catch { }
            
            try { dotNetVersion = System.Environment.Version.ToString(); } catch { }
            
            try { appDomain = AppDomain.CurrentDomain.FriendlyName; } catch { }

            try { compiledWithVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString(); } catch { }

            string environmentInformation;
            if (EnvironmentInformationOverride != null) {
                environmentInformation = EnvironmentInformationOverride; // BuiltInFunction.NewLine() + EnvironmentInformationOverride;
            } else {
                environmentInformation =
                    "eSpaceVer: " + espaceVersion + " (Id=" + espaceVersionId + ", PubId=" + espaceVersionPublishingId + ", CompiledWith=" + compiledWithVersion + ")" +
                    BuiltInFunction.NewLine() + "RequestUrl: " + requestUrl + " (Method: " + requestMethod + ")" +
                    BuiltInFunction.NewLine() + (RuntimePlatformUtils.IsJava() ? "ClassLoader: " : "AppDomain: ") + appDomain +
                    ((filePath != "") ? filePath : BuiltInFunction.NewLine() + "Path: " + applicationPath) +
                    BuiltInFunction.NewLine() + "Locale: " + currentLocale +
                    BuiltInFunction.NewLine() + "DateFormat: " + dateFormat +
                    BuiltInFunction.NewLine() + "PID: " + processId + " ('" + processName + "', Started='" + processStartTime + "', Priv=" + privateMBytes + "Mb, Virt=" + virtualMBytes + "Mb)" +
                    BuiltInFunction.NewLine() + "TID: " + threadId +
                    BuiltInFunction.NewLine() + "Thread Name: " + threadName +
                    (RuntimePlatformUtils.IsJava() ? BuiltInFunction.NewLine() + "JRE: " : BuiltInFunction.NewLine() + ".NET: ") + dotNetVersion;
            }

            return environmentInformation;
        }
    }
}
