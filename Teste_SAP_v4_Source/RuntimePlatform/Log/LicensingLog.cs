/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Diagnostics;
using System.IO;
using System.Text;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;

namespace OutSystems.HubEdition.RuntimePlatform.Log {
    public class LicensingLog {

        private const string LicLogModule = "LicLog";
        private const int MAX_LOG_SIZE = 1000;

        public static void Log(string title, params object[] details) {
            Log(title, true, details);
        }

        public static void LogWithoutStack(string title, params object[] details) {
            Log(title, false, details);
        }

        private static void Log(string title, bool includeStackTrace, params object[] details) {
            try {
                if (Settings.GetBool(Settings.Configs.Log_CollectLicensingInformation)) {
                    var message = new StringBuilder();
                    var applicationPath = "N/A";

                    
                    try {
                        applicationPath = Path.GetFileName(System.Reflection.Assembly.GetEntryAssembly().Location);
                    } catch {
                        // do nothing, leave "N/A"
                    }
                    message.Append(applicationPath + " | ");
                    message.Append(title + " | ");

                    /* sanity check, in case this is used in another way */
                    if (details.Length%2 == 0) {
                        for (var i = 0; i < details.Length; i += 2) {
                            var val = details[i + 1] != null ? details[i + 1].ToString() : "";
                            /* ignore if value is emtpy (to save space) */
                            if (val.IsEmpty()) {
                                continue;
                            }
                            message.Append(String.Format("{0}: {1} | ", details[i], val));
                        }
                    } else {
                        foreach (var detail in details) {
                            message.Append(detail + " | ");
                        }
                    }

                    message.Append(Environment.MachineName);

                    if (includeStackTrace) {
                        message.AppendLine();
                        
                        var stackTrace = Environment.StackTrace;
                        var stack = truncate(stackTrace, MAX_LOG_SIZE - message.Length);
                        message.AppendLine(stack);
                    }

                    GeneralLog.StaticWrite(DateTime.Now, "", 0, 0, 0, message.ToString(), "", LicLogModule, "");
                }
            }
            catch (Exception e) {
                EventLogger.WriteWarning("Could not create licensing log '" + title + "': " + e.Message + "\n" + e.StackTrace);
            }
        }

        /* Logs to server log because it is called by AppInfo. If logged to general log, for example, would cause a loop. */
        public static void LogShutdownCondition(string msg, object[] additionalInfo) {
            var message = new StringBuilder();
            message.AppendLine(msg);
            for (var i = 0; i < additionalInfo.Length; i += 2) {
                message.Append(String.Format("{0}: {1}", additionalInfo[i], additionalInfo[i + 1]) + " | ");
            }
            message.AppendLine(Environment.MachineName);
            EventLogger.WriteWarning(message.ToString());
        }

        /* first 2 lines are the calls to LicLog.Log, which are not relevant */
        private static string deleteFirstLines(string stack) {

            for (var i = 0; i < 2; i++) {
                var newLinePos = stack.IndexOf('\n');
                if (newLinePos > 0) {
                    stack = stack.Substring(newLinePos + 1);
                }
            }
            return stack;
        }

        private static string replaceKeywords(string stack) {
            
            var keywords = new [] {
                "OutSystems", "OS",         "outsystems", "os",
                "HubEdition", "HE",         "hubedition", "he", 
                "RuntimePlatform", "RP",    "runtimeplatform", "rp",
                "RuntimeCommon", "RC",      "runtimecommon", "rc",
                "ServerCommon", "SCmn",     "servercommon", "scmn",
                "Activation", "A",          "activation", "a"
            };

            for (var i = 0; i < keywords.Length; i+=2) {
                stack = stack.Replace(keywords[i], keywords[i + 1]);
            }

            return stack;
        }

        private static string truncate(string stack, int availableLength) {

            if (stack.Length <= availableLength) {
                return stack;
            }

            stack = deleteFirstLines(stack);

            if (stack.Length <= availableLength) {
                return stack;
            }

            stack = replaceKeywords(stack);

            if (stack.Length <= availableLength) {
                return stack;
            }

            stack = stack.Substring(0, availableLength);

            return stack;
        }
    }
}
