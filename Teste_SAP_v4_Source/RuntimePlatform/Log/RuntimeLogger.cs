/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Data;
using System.Diagnostics;
using OutSystems.HubEdition.RuntimePlatform.Db;
using OutSystems.Internal.Db;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.Log;
using OutSystems.RuntimeCommon.Utils;

namespace OutSystems.HubEdition.RuntimePlatform.Log {
    public class RuntimeLogger {

        public delegate LoggerImplementation getRuntimeLogger();
        public delegate void setRuntimeLogger(LoggerImplementation logger);
        public delegate LoggerImplementation setupRuntimeLogger();
        public delegate int indexRuntimeLogger();

        private static volatile getRuntimeLogger GetRuntimeLoggerOverride = null;
        private static volatile setRuntimeLogger SetRuntimeLoggerOverride = null;
        private static volatile setupRuntimeLogger SetupRuntimeLoggerOverride = null;

        private static LogThrottle logthrottle = new LogThrottle(2);

        public static void OverrideRuntimeLogger(getRuntimeLogger getOverride, setRuntimeLogger setOverride, setupRuntimeLogger setupOverride) {
            lock (typeof (RuntimeLogger)) {                
                GetRuntimeLoggerOverride = getOverride;
                SetRuntimeLoggerOverride = setOverride;
                SetupRuntimeLoggerOverride = setupOverride;
            }
        }

        public static volatile bool DisableLogs = false;

        // --- Modificação pós-detach para Log Sincrono em BD ---
        // private static string applicationName = "Undefined Application";
        private static string applicationName = "Teste_SAP";
        // --- FIM ---

        private static volatile LoggerImplementation loggerInstance = null;

        public static LoggerImplementation LoggerInstance {
            get {
                //lock (typeof(RuntimeLogger)) {
                    if (loggerInstance == null) {
                        lock (typeof (RuntimeLogger)) {
                            if (loggerInstance == null) {
                                
                                // --- Modificação pós-detach para Log Sincrono em BD ---
                                // loggerInstance = NullLogger.Instance;
                                loggerInstance = GetRuntimeLogger();
                                // --- FIM ---
                            }
                        }
                    }
                    return loggerInstance;
                //}
            }
            private set {
                lock (typeof(RuntimeLogger)) {
                    loggerInstance = value;
                }
            }
        }
        private static bool ApplicationMonitoringEnabled {
            get {
                var info = AppInfo.GetAppInfo();
                return info != null ? info.ApplicationMonitoringEnabled : true;
            }
        }

        public static bool LogAsynchronousEnabled {
            get {
                return false;
            }
        }

        public static void SetUp(string applicationName, bool ignoreExceptions) {
            lock (typeof(RuntimeLogger)) {
                RuntimeLogger.applicationName = applicationName;
                OSTrace.PublishLog = new PublishLog();
            }
        }

        private static void SetUpLoggerInstance(bool ignoreExceptions) {
            if (ignoreExceptions) {
                lock (typeof(RuntimeLogger)) {
                    try {
                        LoggerInstance = GetRuntimeLogger();
                    } catch (Exception e) {
                        EventLogger.WriteError("Error initializing logger for " + applicationName + ": " + e.ToString());
                    }
                }
            } else {
                lock (typeof(RuntimeLogger)) {
                    LoggerInstance = GetRuntimeLogger();
                }
            }
        }

        private static LoggerImplementation GetRuntimeLogger() {
            // --- Modificação pós-detach para Log Sincrono em BD ---
            // LoggerImplementation logger = new NullLogger();
            LoggerImplementation logger = new LoggerSynchronous();
            // --- FIM ---

            logger.SetUp();
            return logger;
        }

        public static void Log(CyclicJobLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Stop() {
            LoggerInstance.Stop();
        }

        public static void Log(ErrorLog log) {
            Log(log, false);
        }

        public static void Log(ErrorLog log, bool forceSynchronous) {
            try {
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteError(log.Message);
                }
            } catch (Exception e) {
                EventLogger.WriteError("Error sending log: " + e.ToString());
            }
        }

        public static void Log(GeneralLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                if (log.ModuleName == "ALARM") {
                    EventLogger.WriteWarning(log.Message);
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ScreenLog screenLog) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                
                switch (screenLog.ScreenType) {
                    case "WEB":
                        break;
                    case "SMS":
                        break;
                    default:
                        break;
                }
                LoggerInstance.Log(screenLog);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(ExtensionLog extensionLog) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(extensionLog);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(SmsLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(WebReferenceLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(WebServiceLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);

            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(IntegrationLog log) {
            try {
                if (!ApplicationMonitoringEnabled)
                    return;
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(IntDetailLog log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                if (LoggerInstance != null) {
                    LoggerInstance.Log(log);
                } else {
                    EventLogger.WriteInfo(log.Message);
                }
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void LogPublishTrace(DateTime instant, int milliseconds, string eSpaceKey, string step, bool isStart, int traceKindId, string extraInfo, string parentStep) {
            try {
                if (LogAsynchronousEnabled) {
                    var publishLog = new CustomLog("PublishTrace", "OSSYS_PUBLISHTRACE", 0, null, 
                        DatabaseAccess.ForSystemDatabase.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier);

                    publishLog.Fields.Add("ESPACE_SS_KEY", new CustomLog.CustomLogField(eSpaceKey, false, false));
                    publishLog.Fields.Add("STEP", new CustomLog.CustomLogField(step, false, false));
                    publishLog.Fields.Add("INSTANT", new CustomLog.CustomLogField(instant, false, false));
                    publishLog.Fields.Add("ISSTART", new CustomLog.CustomLogField(isStart ? 1 : 0, false, false));
                    publishLog.Fields.Add("TRACEKINDID", new CustomLog.CustomLogField(traceKindId, false, false));
                    publishLog.Fields.Add("EXTRAINFO", new CustomLog.CustomLogField(extraInfo, false, false));
                    publishLog.Fields.Add("PARENTSTEP", new CustomLog.CustomLogField(parentStep, false, false));
                    publishLog.Fields.Add("MILLISECONDS", new CustomLog.CustomLogField(milliseconds, false, false));

                    try {
                        LoggerInstance.Log(publishLog);
                    } catch (Exception e) {
                        EventLogger.WriteError("Error sending publish log: " + e.ToString());
                    }
                }
            } catch (Exception e) {
                EventLogger.WriteError("Error sending publish log: " + e.ToString());
            }
        }

        public static void LogVisit(DateTime instant, string visitorUID, string visitUID) {
            var visitLog = new CustomLog("Visit", "OSSYS_VISIT", 0, null, 
                DatabaseAccess.ForSystemDatabase.DatabaseServices.DatabaseConfiguration.DatabaseIdentifier);

            visitLog.Fields.Add("INSTANT", new CustomLog.CustomLogField(instant, false, false));
            visitLog.Fields.Add("VISITORUID", new CustomLog.CustomLogField(visitorUID, false, false));
            visitLog.Fields.Add("VISITUID", new CustomLog.CustomLogField(visitUID, false, false));

            try {
                LoggerInstance.Log(visitLog);
            } catch (Exception e) {
                EventLogger.WriteError("Error sending log: " + e.ToString());
            }
        }

        public static void Log(CustomLog log) {
            try {
                if (!ApplicationMonitoringEnabled) {
                    return;
                }
                LoggerInstance.Log(log);
            } catch (NotSupportedException) {
                throw;
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        public static void Log(RequestEvent log) {
            try {
                if (!RuntimePlatformUtils.GetRequestEventEspaceProperties(log.ModuleKey).PerformanceMonitoringEnabled) {
                    return;
                }
                LoggerInstance.Log(log);
            } catch (Exception e) {
                logthrottle.WriteErrorWithThrottle(EventLogger.WriteError, "Error sending log: " + e.ToString());
            }
        }

        
        private static DateTime referenceDate = new DateTime(2000, 1, 1, 0, 0, 0);

        
        public static int CalculateIndex(DateTime current, int cycleSize) {
            return CalculateIndex(current, cycleSize, null);
        }

        public static int CalculateIndex(DateTime current, int cycleSize, Transaction trans) {
            int cyclePeriod = 7; // 1 week default
            try {
                cyclePeriod = Settings.GetInt(Settings.Configs.LogServer_Db_CyclePeriod, trans);
            } catch {
            }
            return CalculateIndex(current, cycleSize, cyclePeriod);
        }

        
        public static int CalculateIndex(DateTime current, int cycleSize, int cyclePeriod) {
            return ((((TimeSpan)current.Subtract(referenceDate)).Days / cyclePeriod) % cycleSize);
        }

        public static int CalculateLastDirtyIndex(int cycleSize, int cyclePeriod, int windowSize) {
            
            int current = CalculateIndex(DateTime.Now, cycleSize, cyclePeriod);
            // This may look more complicated than needed, but guards against very big or negative windowSize's...
            current = (current - windowSize) % cycleSize;

            return (current >= 0 ? current : current + cycleSize);
        }
        
        public static int CalculateLastDirtyIndex(int cycleSize, int windowSize) {
            
            int current = CalculateIndex(DateTime.Now, cycleSize);
            // This may look more complicated than needed, but guards against very big or negative windowSize's...
            current = (current - windowSize) % cycleSize;

            return (current >= 0 ? current : current + cycleSize);
        }

        public static int CalculatePreviousIndex(int currentIndex, int cycleSize) {
            int current = (currentIndex - 1) % cycleSize;
            return (current >= 0 ? current : current + cycleSize);
        }

        public static void SetDisableLogs(bool value) {
            lock (typeof (RuntimeLogger)) {
                DisableLogs = value;
            }
        }
    }
}
