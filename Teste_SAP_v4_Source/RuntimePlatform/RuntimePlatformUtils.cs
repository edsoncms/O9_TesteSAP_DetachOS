/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.Serialization.Formatters.Binary;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Web;
using System.Runtime.CompilerServices;
using OutSystems.HubEdition.RuntimePlatform.Internal;
using OutSystems.Internal.Db;
using OutSystems.HubEdition.RuntimePlatform.SessionState;
using OutSystems.ObjectKeys;
using OutSystems.RuntimeCommon;
using OutSystems.HubEdition.RuntimePlatform.IPAddressRangeLib;
using OutSystems.HubEdition.RuntimePlatform.WebReference;

namespace OutSystems.HubEdition.RuntimePlatform {

    public partial class RuntimePlatformUtils {
        // Slow extensions logging
        private static int ExtensionTreshold = 200; // this value means nothing as it will be read from the database
        private static volatile bool ExtensionTresholdKnown = false;
        private static object ExtensionTresholdLockObject = new object();
        public static bool ShouldCreateCookieForRequest() {
            return !HttpContext.Current.Request.UserAgent.IsEmpty() &&
                !HttpContext.Current.Request.UserAgent.Contains("RichMail") &&
                !HttpContext.Current.Request.UserAgent.Contains("Apache-HttpClient") &&
                !Settings.GetBool(Settings.Configs.DisableMetricsCollect);
        }

        public static bool IsValidRequestForVisit() {
            return ShouldCreateCookieForRequest() && !NetworkInterfaceUtils.IsLoopbackAddress(HttpContext.Current.Request.UserHostAddress);
        }

        /// <summary>
        /// This is the extension for the eSpace cache files... used by the compiler and the compiler service...
        /// </summary>
        public const string CacheFileExtension = ".cache";

        /// <summary>
        /// This is the extesion for the cache control files... those used by the tenant invalidate cache, etc...
        /// </summary>
        public const string CACHE_CONTROL_FILE_EXT = ".osc";

        private static string RetrievedSessionSize = "RetrievedSessionSize";
        public static int GetRetrievedSessionSize() {
            if (System.Web.HttpContext.Current.Items[RetrievedSessionSize] == null) {
                return 0;
            } else {
                return (int)System.Web.HttpContext.Current.Items[RetrievedSessionSize];
            }
        }

        public static void SetRetrievedSessionSize(HttpContext context, int val) {
            context.Items[RetrievedSessionSize] = val;
        }

        public static void IncrementRetrievedSessionSize(int val) {
            HttpContext.Current.Items[RetrievedSessionSize] = GetRetrievedSessionSize() + val;
        }

        private static string RetrievedSessionRequests = "RetrievedSessionRequests";

        public static int GetRetrievedSessionRequests() {
            if (System.Web.HttpContext.Current.Items[RetrievedSessionRequests] == null) {
                return 1;
            } else {
                return (int)System.Web.HttpContext.Current.Items[RetrievedSessionRequests];
            }
        }
        public static void IncrementRetrievedSessionRequests() {
            HttpContext.Current.Items[RetrievedSessionRequests] = GetRetrievedSessionRequests() + 1;
        }

        private static string ViewstateSize = "ViewstateSize";
        public static int GetViewstateSize() {
            if (System.Web.HttpContext.Current.Items[ViewstateSize] == null) {
                return 0;
            } else {
                return (int)System.Web.HttpContext.Current.Items[ViewstateSize];
            }
        }
        public static void SetViewstateSize(int val) {
            System.Web.HttpContext.Current.Items[ViewstateSize] = val;
        }

        public static string ExecuteDataBind(System.EventHandler databind, object sender) {
            return ExecuteDataBind(databind, sender, null);
        }

        public static string ExecuteDataBind(System.EventHandler databind, object sender, System.EventArgs args) {
            databind(sender, args);
            return string.Empty;
        }

        private static long TicksFrom1900_3_1 = new DateTime(1900, 3, 1).Ticks;

        public static object ExcelFixWrongDateTimeVals(object val) {
            if (val is DateTime && ((DateTime)val).Ticks < TicksFrom1900_3_1) {
                val = ((DateTime)val).AddDays(-1);
            }
            return val;
        }

        public static bool AppendStaticSuffixForLevel(CacheInvalidationMangleDepth level) {
            string userlevel = Settings.Get(Settings.Configs.Compiler_UseCacheInvalidationSuffix);
            switch (userlevel.ToLowerInvariant()) {
                case "all":
                    return true;
                case "css":
                    return true;
                case "pagecontents":
                    return (level == CacheInvalidationMangleDepth.PlatformInserted || level == CacheInvalidationMangleDepth.None);
                case "none":
                    return (level == CacheInvalidationMangleDepth.None);
                default:
                    return false;
            }
        }


        public static string EncodeFilenameForDownload(string filename) {
            return HttpUtility.UrlEncode(filename).Replace("+", " ");
        }

        // #155815 Removed the regex aplied to the filename to alow more characters.
        // According to this (http://tools.ietf.org/html/rfc822#section-3.1) we can use double quotes to do that in the header.
        // Now it apply this regex [\*\|\\:\<">?/] to the original filename, writing the result of the regex.replace between double quotes.
        public static string EscapeFilenameForDownload(string filename) {
            return Regex.Replace(filename.Trim(), "[\\*\\|:<>\\\"\\\\?/\\r\\n]", "", RegexOptions.Singleline);
        }


        public static string GetHostNameForJava() {
            return null;
        }

        [Obsolete("Use NetworkInterfaceUtils.IsLoopbackAddress instead")]
        public static bool isLoopbackAddress(string hostnameOrIp) {
            return NetworkInterfaceUtils.IsLoopbackAddress(hostnameOrIp);
        }

        [Obsolete("Use NetworkInterfaceUtils.RemoveScopeIdFromIp instead")]
        public static string removeScopeIdFromIp(string ip) {
            return NetworkInterfaceUtils.RemoveScopeIdFromIp(ip);
        }

        public static Encoding DefaultEncoding;

        public static void InitDefaultEncoding(bool isJava) {
            // The .NET encoding must use BOM, while the Java encoding can't use BOM
            // This is here to ensure the correct encoding is used for each stack
            DefaultEncoding = new UTF8Encoding(!isJava);
        }

        public static readonly string LateLoadBinariesDirectory = "bin2";

        public static readonly string ExtensionBinariesDirectory = "bin2";

        public static bool IsDefaultEncodingString(byte[] data) {
            if (data.Length > 2) {
                // The UTF-8 identifier is the Unicode byte order mark (0xFEFF) written in UTF-8 (0xEF 0xBB 0xBF).
                return (0xff & data[0]) == 0xEF && (0xff & data[1]) == 0xBB && (0xff & data[2]) == 0xBF;
            }
            return false;
        }

        private static ArrayList _internalIPAddresses = null;

        public static void LoadInternalIPAddresses() {
            lock (typeof(RuntimePlatformUtils)) {
                string ipList = Settings.Get(Settings.Configs.InternalNetwork_IPAdresses);
                if (ipList == null) {
                    throw new InvalidOperationException("Invalid or missing OutSystems.HubEdition.InternalNetwork.IPAdresses");
                }
                _internalIPAddresses = new ArrayList();
                foreach (string ip in ipList.Split(';')) {
                    if (ip != "") {
                        if (IPAddressValidationLegacy(ip.Trim())) {
                            _internalIPAddresses.Add(ip.Trim());
                        }
                    }
                }
            }
        }

        public static ApplicationServerStack getServerStack() {
#if JAVA
            return ApplicationServerStack.Java;
#else
            return ApplicationServerStack.Net;
#endif
        }

        public static bool IsJava() {
            return getServerStack() == ApplicationServerStack.Java;
        }

        //#49674
        public static readonly string SessionPrefixJava = "(";
        public static readonly string SessionPrefixDotNET = "(S(";
        public static readonly string SessionSuffixJava = ")";
        public static readonly string SessionSuffixDotNET = "))";

        public static string SessionPrefix {
            get {
                if (IsJava()) {
                    return SessionPrefixJava;
                } else {
                    return SessionPrefixDotNET;
                }
            }
        }

        public static string SessionSuffix {
            get {
                if (IsJava()) {
                    return SessionSuffixJava;
                } else {
                    return SessionSuffixDotNET;
                }
            }
        }

        [Obsolete("Please use GetLibFileExtension()")]
        public static string GetLibFileExtension(ApplicationServerKind serverKind) {
            return GetLibFileExtension();
        }

        public static string GetLibFileExtension() {
            if (!IsJava()) {
                return ".dll";
            } else {
                return ".jar";
            }
        }

        [Obsolete("Please use GetUIFileExtension()")]
        public static string GetUIFileExtension(ApplicationServerKind serverKind) {
            return GetUIFileExtension();
        }

        public static string GetUIFileExtension() {
            if (!IsJava()) {
                return ".ascx";
            } else {
                return ".jsp";
            }
        }

        [Obsolete("Please use GetLibDirectoryName()")]
        public static string GetLibDirectoryName(ApplicationServerKind serverKind) {
            return GetLibDirectoryName();
        }

        public static string GetLibDirectoryName() {
            if (!IsJava()) {
                return "bin";
            } else {
                return "lib";
            }
        }

        [Obsolete("Please use GetUIDirectoryName()")]
        public static string GetUIDirectoryName(ApplicationServerKind serverKind) {
            return GetUIDirectoryName();
        }

        public static string GetUIDirectoryName() {
            if (!IsJava()) {
                return "";
            } else {
                return "jsp";
            }
        }

        [Obsolete("Please use GetWidgetsDirectoryName()")]
        public static string GetWidgetsDirectoryName(ApplicationServerKind serverKind) {
            return GetWidgetsDirectoryName();
        }

        public static string GetWidgetsDirectoryName() {
            if (!IsJava()) {
                return "Blocks";
            } else {
                return "jsp" + FileSystemUtils.PathSeparator + "Blocks";
            }
        }

        public static string GetCodeBehindLibSuffix() {
            return "CodeBehind";
        }

        [Obsolete("Please use GetImagesDirectoryName()")]
        public static string GetImagesDirectoryName(ApplicationServerKind serverKind) {
            return GetImagesDirectoryName();
        }

        public static string GetImagesDirectoryName() {
            if (!IsJava()) {
                return "img";
            } else {
                return "jsp" + FileSystemUtils.PathSeparator + "img";
            }
        }

        public static string RemoveTrailingZeros(string str, NumberFormatInfo formatInfo) {
            int pos;
            if (str == null) {
                return str;
            }
            if (str.IndexOf(formatInfo.NumberDecimalSeparator) == -1) {
                return str;
            }
            pos = str.Length - 1;
            while (str[pos] == '0') {
                pos--;
            }
            // Remove the last .
            if (formatInfo.NumberDecimalSeparator.IndexOf(str[pos]) != -1) {
                pos--;
            }
            str = str.Substring(0, pos + 1);
            return str;
        }

        /// <summary>
        /// Stops execution until VS Debugger is attached
        /// </summary>
        public static void CheckAndWaitForDebugger() {
            bool waitForDebugger;
            if (DatabaseAccess.BlockAccess || !Boolean.TryParse(Settings.Get(Settings.Configs.Service_WaitForDebugger), out waitForDebugger)) {
                waitForDebugger = false;
            }
            if (waitForDebugger) {
                OSTrace.TimerStart("Waiting for Debugger");
                while (true) {
                    if (System.Diagnostics.Debugger.IsAttached) {
                        break;
                    }
                    System.Threading.Thread.Sleep(1000);
                }
                OSTrace.TimerEnd("Waiting for Debugger");
            }
        }

        public static string JavaScriptEscString(string s) {
            return BuiltInFunction.EncodeJavascript(s);
        }

        public static string ConvertCRLFToWhitespace(string text) {
            text = text.Replace("\r\n", " ");
            text = text.Replace("\n", " ");
            text = text.Replace("\r", " ");
            return text;
        }

        public static string ExtendedHtmlEncode(string s) {
            return BuiltInFunction.EncodeHtml(s);
        }

        public static string GetSession(string eSpaceName, string tenantName, bool isMultitenant) {
            string url = "http://localhost/" + eSpaceName + "/_ping.aspx";
            HttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);
            request.Method = "HEAD";
            request.AllowAutoRedirect = false;
            HttpWebResponse response = null;
            string session = "";
            try {
                response = (HttpWebResponse)request.GetResponse();
                if (response.StatusCode == HttpStatusCode.Found) {
                    string[] splitRes = response.Headers["Location"].Split(new string[] { RuntimePlatformUtils.SessionPrefix, RuntimePlatformUtils.SessionSuffix }, StringSplitOptions.None); // #49674
                    if (splitRes.Length > 3) {
                        throw (new InvalidOperationException("Result contains parenthesis... " + response.Headers["Location"]));
                    }
                    session = splitRes[1];
                }
            } finally {
                try {
                    if (response != null) {
                        response.Close();
                    }
                } catch {
                }
            }
            return session;
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId) {
            return TestAndSetTimerNextRun(heContext, timerKey, producerEspaceId, AppInfo.GetAppInfo().Tenant.Id);
        }

        public static bool TestAndSetTimerNextRun(HeContext heContext, ObjectKey timerKey, int producerEspaceId, int tenantId) {
            using (Transaction privTran = DatabaseAccess.ForSystemDatabase.GetCommitableTransaction()) {
                // Check if the timer is running. If so, do nothing and return false
                bool isShared;
                int cyclicJobId = DBRuntimePlatform.Instance.GetCyclicJobId(privTran, producerEspaceId, tenantId, timerKey, out isShared);
                DateTime isRunningSince, lastRun, nextRun;
                string schedule, isRunBy;
                bool result = false;
                if (DBRuntimePlatform.Instance.GetCyclicJobForUpdate(privTran, cyclicJobId, isShared, out isRunningSince, out schedule,
                    out lastRun, out nextRun, out isRunBy)) {

                    result = isRunningSince == BuiltInFunction.NullDate();
                    DBRuntimePlatform.Instance.UpdateCyclicJob(privTran, cyclicJobId, isShared);
                    privTran.Commit();
                }
                return result;
            }
        }

        [Obsolete("Deprecated. Please get tenantId and eSpaceId from session.")]
        public static void GetRunningIDs(int producerEspaceId, out int tenantId, out int eSpaceId) {
            AppInfo app = AppInfo.GetAppInfo();
            tenantId = app.Tenant.Id;
            eSpaceId = producerEspaceId;
        }

        public static bool CompareByteArrays(byte[] arr1, byte[] arr2) {
            if (arr1.Length != arr2.Length) {
                return false;
            }
            for (int i = 0; i < arr1.Length; i++) {
                if (arr1[i] != arr2[i]) {
                    return false;
                }
            }
            return true;
        }

        private static bool IPAddressValidation(string ipAddress, out IPAddress address) {
            return IPAddress.TryParse(ipAddress, out address);
        }

        public static bool IPAddressIsValidIPv4(string ipAddress) {
            Match m = Regex.Match(
                ipAddress,
                "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        public static bool IPAddressIsValidIPv6(string ipAddress) {
            Match m1 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            Match m2 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?) ::((?:[0-9A-Fa-f]{1,4}:)*)(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)(\\.(25[0-5]|2[0-4]\\d|[0-1]?\\d?\\d)){3}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            Match m3 = Regex.Match(
                ipAddress,
                "\\A((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)::((?:[0-9A-Fa-f]{1,4}(?::[0-9A-Fa-f]{1,4})*)?)(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            Match m4 = Regex.Match(
                ipAddress,
                "\\A(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}(?:%[0-9A-Za-z]*)?\\z",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);

            return m1.Success || m2.Success || m3.Success || m4.Success;
        }

        private static bool IPAddressValidationLegacy(string ipAddress) {
            Match m;
            m = Regex.Match(
                ipAddress,
                @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)|" +
                    @"(^(\d|\d\d|1\d\d|2[0-4]\d|25[0-5])\.{0,1}$)",
                RegexOptions.IgnoreCase | RegexOptions.Singleline);
            return m.Success;
        }

        private static bool IPAddressValidation(string ipAddress) {
            IPAddress dummy;
            return IPAddressValidation(ipAddress, out dummy);
        }

        public static bool InternalAddressIdentification(HttpRequest request) {
            // If the feature is disabled, we just use UserHostAddress which was the old behavior (dumped by the compiler).
            var requestAddress = request.UserHostAddress;

            // When enabled, we use the new code under GetRequestRealIP.
            if (Settings.GetBool(Settings.Configs.EnableTrustedProxies)) {
                requestAddress = GetRequestRealIP(request);
            }

            return InternalAddressIdentification(requestAddress);
        }

        // Avoid using this method. Use the one receiving HttpRequest instead.
        public static bool InternalAddressIdentification(string ipAddress) {
            if (_internalIPAddresses == null) {
                LoadInternalIPAddresses();
            }

            foreach (string ip in _internalIPAddresses) {
                if (ipAddress.StartsWith(ip)) {
                    return true;
                }
            }
            return (_internalIPAddresses.Count == 0);
        }

        public static string BitToSSBoolean(object field) {
            return (Convert.ToBoolean(field)) ? "Yes" : "No";
        }

        /// <summary>
        /// Convert an object to string
        /// To be used for saving values in a database string field
        /// </summary>
        /// <param name="val">Object to be converted into a String.</param>
        /// <returns>A String representing the given object</returns>
        public static string ConvertToString(object val) {
            if (val is DateTime) {
                return ((DateTime)val).ToString(Constants.DateTimeFormat, Constants.DateTimeFormatProvider);
            } else if (val is Decimal) {
                return BuiltInFunction.DecimalToText((Decimal)val);
            } else if (val is Boolean) {
                return ((bool)val) ? "True" : "False";
            } else {
                return val.ToString();
            }
        }

        /// <summary>
        /// Convert an string to object.
        /// To be used for retrieve values from a database string field
        /// </summary>
        /// <param name="val">String to be converted</param>
        /// <param name="datatype">The runtime string representation of the desired datatype.</param>
        /// <returns>An object created from the given String based on the data type.</returns>
        public static object ConvertFromString(string val, string datatype) {
            switch (datatype) {
                case "rtText":
                case "rtPhoneNumber":
                case "rtEmail":
                    return val;
                case "rtInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt32(val);
                case "rtLongInteger":
                    if (val == string.Empty) {
                        val = "0";
                    }
                    return Convert.ToInt64(val);
                case "rtDecimal":
                case "rtCurrency":
                    if (val == string.Empty) {
                        val = "0.0";
                    }
                    return ScriptableBuiltInFunction.TextToDecimal(val);
                case "rtBoolean":
                    if (val == string.Empty) {
                        val = "true";
                    }
                    return val.ToLower() == "true";
                case "rtDateTime":
                    if (val == "") {
                        val = "1900-01-01 00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToDateTime(val);
                case "rtDate":
                    if (val == "") {
                        val = "1900-01-01";
                    }
                    return ScriptableBuiltInFunction.TextToDate(val);
                case "rtTime":
                    if (val == "") {
                        val = "00:00:00";
                    }
                    return ScriptableBuiltInFunction.TextToTime(val);
                default:
                    throw (new ArgumentException("Don't know how to convert " + datatype));
            }
        }

        // If input string is null, returns "" instead
        public static string NoNull(string inStr) {
            return inStr ?? string.Empty;
        }

        public static string Trunc(string s, int len) {
            if (s.Length > len) {
                return s.Substring(0, len);
            } else {
                return s;
            }
        }

        public static string TruncNoNull(string str, int maxSize) {
            return RuntimePlatformUtils.Trunc(RuntimePlatformUtils.NoNull(str), maxSize);
        }

        public static string GetPrettyStackTrace(StackTrace st) {
            StackTrace trace1;
            string text1;
            StringBuilder builder1;
            int num1;
            StackFrame frame1;
            MethodBase base1;
            Type type1;
            string text2;
            ParameterInfo[] array1;
            int num2;
            string text3;
            string text4;
            object[] array2;
            trace1 = st;
            text1 = Environment.NewLine;
            builder1 = new StringBuilder(255);
            for (num1 = 0; (num1 < trace1.FrameCount); num1 = (num1 + 1)) {
                frame1 = trace1.GetFrame(num1);
                builder1.Append(" at ");
                base1 = frame1.GetMethod();
                type1 = base1.DeclaringType;
                if (type1 != null) {
                    text2 = type1.Namespace;
                    if (text2 != null) {
                        builder1.Append(text2);
                        if (builder1 != null) {
                            builder1.Append(".");
                        }
                    }
                    builder1.Append(type1.Name);
                    builder1.Append(".");
                }
                builder1.Append(base1.Name);
                builder1.Append("(");
                array1 = base1.GetParameters();
                for (num2 = 0; (num2 < array1.Length); num2 = (num2 + 1)) {
                    text3 = "<UnknownType>";
                    if (array1[num2].ParameterType != null) {
                        text3 = array1[num2].ParameterType.Name;
                    }
                    builder1.Append(string.Concat(((num2 != 0) ? ", " : ""), text3, " ", array1[num2].Name));
                }
                builder1.Append(")");
                if (frame1.GetILOffset() != -1) {
                    text4 = frame1.GetFileName();
                    if (text4 != null) {
                        array2 = new object[4];
                        array2[0] = " in ";
                        array2[1] = text4;
                        array2[2] = ":line ";
                        array2[3] = frame1.GetFileLineNumber();
                        builder1.Append(string.Concat(array2));
                    }
                }
                if (num1 != (trace1.FrameCount - 1)) {
                    builder1.Append(text1);
                }
            }
            return builder1.ToString();
        }

        public static void RedirectAndroidDownloadToExternalPage(string url) {
            HttpContext context = HttpContext.Current;
            HttpResponse response = context.Response;
            response.Clear();
            response.StatusCode = 302;
            
            {
                url = response.ApplyAppPathModifier(url);
                response.StatusDescription = "Found";
            }
            response.AddHeader("Location", url);
            response.CacheControl = "private";
            
            response.Write("<html><head><title>No title</title></head><body><h2>Object moved to <a href='" + HttpUtility.HtmlEncode(url) + "'>here</a>.</h2></body></html>\r\n");
            response.Flush();
        }

        private static HEMessageException HandleReadPersistentDataException(string fullPath, Exception ex) {
            HEMessage he = new HEMessage("PersistenceCacheReadError",
                                         "Internal Error",
                                         "Could not load persistence information file '" + fullPath + "'" + (ex != null ? (": " + ex.Message) : ""),
                                         2063,
                                         ex != null ? ex.StackTrace : "",
                                         HEMessageType.Error,
                                         true);
            return new HEMessageException(he);
        }

        private static HEMessageException HandleWritePersistentDataException(string fullPath, Exception ex) {
            HEMessage he = new HEMessage("PersistenceCacheCreateError",
                                         "Internal Error",
                                         "Could not create persistence information file '" + fullPath + "'" + (ex != null ? (": " + ex.Message) : ""),
                                         2063,
                                         ex != null ? ex.StackTrace : "",
                                         HEMessageType.Error,
                                         true);
            return new HEMessageException(he);
        }

        public static object TryReadPersistentData(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                return null;
            }
            FileStream fs = null;
            try {
                fs = File.OpenRead(fullPath);
                BinaryFormatter bf = new BinaryFormatter();
                return bf.Deserialize(fs);
            } catch (Exception) {
                return null;
            } finally {
                if (fs != null) {
                    fs.Close();
                }
            }
        }

        public static object ReadPersistentData(string filename) {
            return ReadPersistentData("", filename);
        }

        public static object ReadPersistentData(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                throw HandleReadPersistentDataException(fullPath, /*Exception*/null);
            }
            FileStream fs = null;
            try {
                fs = File.OpenRead(fullPath);
                BinaryFormatter bf = new BinaryFormatter();
                return bf.Deserialize(fs);
            } catch (Exception e) {
                throw HandleReadPersistentDataException(fullPath, e);
            } finally {
                if (fs != null) {
                    try {
                        fs.Close();
                    } catch (Exception e) {
                        throw HandleReadPersistentDataException(fullPath, e);
                    }
                }
            }
        }


        public static void WritePersistentData(string path, string filename, object data) {
            Stream fs = null;
            try {
                fs = CreateCacheFile(path, filename);
                BinaryFormatter bf = new BinaryFormatter();
                bf.Serialize(fs, data);
            } finally {
                if (fs != null) {
                    fs.Close();
                }
            }
        }

        public static Stream CreateCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            try {
                return File.Create(fullPath);
            } catch (Exception e) {
                throw HandleWritePersistentDataException(fullPath, e);
            }
        }

        public static bool CacheFileExists(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            return File.Exists(fullPath);
        }

        public static Stream OpenCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            if (!File.Exists(fullPath)) {
                throw HandleReadPersistentDataException(fullPath, /*Exception*/null);
            }
            try {
                return File.OpenRead(fullPath);
            } catch (Exception e) {
                throw HandleReadPersistentDataException(fullPath, e);
            }
        }

        public static void DeleteCacheFile(string path, string filename) {
            string fullPath = GetCacheFileName(path, filename);
            try {
                if (File.Exists(fullPath)) {
                    File.Delete(fullPath);
                }
            } catch (Exception e) {
                HEMessage he = new HEMessage("PersistenceCacheDeleteError",
                                             "Internal Error",
                                             "Could not delete persistence information file '" + fullPath + "' " + e.Message,
                                             0,
                                             e.StackTrace,
                                             HEMessageType.Error,
                                             true);
                throw new HEMessageException(he);
            }
        }

        public static string GetCacheFileName(string path, string filename) {
            string fullPath = String.IsNullOrEmpty(path) ? String.Empty : Path.GetFullPath(path);
            string fullPathFilename = String.IsNullOrEmpty(filename) ? String.Empty : Path.GetFullPath(filename);
            string filepath;
            if (fullPath.IsEmpty() || fullPathFilename.StartsWith(fullPath)) {
                filepath = filename + CacheFileExtension;
            } else {
                filepath = Path.Combine(path, filename + CacheFileExtension);
            }
            return Path.GetFullPath(filepath);
        }

        private struct ActionAndBlockReferencesIds {
            public readonly int id, versionId;
            public ActionAndBlockReferencesIds(int id, int versionId) {
                this.id = id;
                this.versionId = versionId;
            }
        }

        private static void AddActionAndBlockReferencesEspaceIdsRecurse(int versionId, int eSpaceId, ArrayList visited, Transaction tran) {
            visited.Add(eSpaceId);

            LinkedList<ActionAndBlockReferencesIds> ids = new LinkedList<ActionAndBlockReferencesIds>();
            using (IDataReader reader = DBRuntimePlatform.Instance.GetActionAndBlockReferencesInfo(tran, versionId)) {
                ids.AddLast(new ActionAndBlockReferencesIds(Convert.ToInt32(reader["ID"]), Convert.ToInt32(reader["VERSION_ID"])));
            }

            foreach (ActionAndBlockReferencesIds id in ids) {
                int refEspaceId = id.id;
                int refVersionId = id.versionId;
                if (!visited.Contains(refEspaceId)) {
                    AddActionAndBlockReferencesEspaceIdsRecurse(refVersionId, refEspaceId, visited, tran);
                }
            }
        }

        public static ArrayList GetActionAndBlockReferencesEspaceIds(int eSpaceId) {
            ArrayList eSpaceIds = new ArrayList();
            int thisVersionId;

            using (Transaction tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                //get producer tenant id
                object Id = DBRuntimePlatform.Instance.GetVersionIdFromEspaceId(tran, eSpaceId);
                if (!(Id is System.DBNull)) {
                    thisVersionId = Convert.ToInt32(Id);
                    AddActionAndBlockReferencesEspaceIdsRecurse(thisVersionId, eSpaceId, eSpaceIds, tran);
                    eSpaceIds.Remove(eSpaceId);
                }
            }
            return eSpaceIds;
        }

        public static void SetScriptTimeout(int timeoutInSecs) {
            if (timeoutInSecs == 0) {
                throw new ArgumentOutOfRangeException("timeoutInSecs", "The timeout for HTTP requests should be different from 0 (zero).");
            }
            
            HttpContext.Current.Server.ScriptTimeout = timeoutInSecs;
        }

        public static void SetSessionItemTimeout(int timeoutInMins) {
            // obtain current session
            System.Web.SessionState.HttpSessionState session = HttpContext.Current.Session;
            // check if it is necessary to set the new timeout
            if (session != null && session.Timeout != timeoutInMins) {
                session.Timeout = timeoutInMins;
                SqlSessionStateStore.SetItemTimeout(session.SessionID, timeoutInMins);
            }
        }

        public static bool IsSocketException(Exception ex) {
            
            return ex is System.Net.Sockets.SocketException;
        }

        public static bool isWindows() {
            
            return true;
        }

        public static bool TestAndSetProducerSession(string eSpaceName) {
            if (HttpContext.Current.Session != null) {
                HeContext heContext = AppInfo.GetAppInfo().OsContext;
                return heContext.Session.TestAndSetNeedsSessionStart(eSpaceName);
            }
            return false;
        }

        public static bool PersistentDataExists(string path, string filename) {
            return File.Exists(GetCacheFileName(path, filename));
        }

        public static string connectionStringJoin(string conStr, string parameters) {
            if (!conStr.TrimEnd().EndsWith(";")) {
                conStr += ";";
            }

            return conStr + (parameters ?? "");
        }

        public static bool RequestIsSecure(HttpRequest request) {
            return RequestIsHttps(request);
        }


        // Returns the protocol for the current request, as seen in the browser.
        public static bool RequestIsHttps(HttpRequest request) {
            if (request.IsSecureConnection) {
                return true;
            }

            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = Settings.Get(Settings.Configs.HTTPtoHTTPSproxyHeader);

            if (!String.IsNullOrEmpty(httpToHttpsProxyHeader)) {
                string[] headerParts = httpToHttpsProxyHeader.Split(new char[] { ':' }, 2);
                string requestHeaderValue = request.Headers[headerParts[0].Trim()];

                if (requestHeaderValue == null) {
                    return false;   // The header isn't present in the request
                } else if (headerParts.Length == 1) {
                    return true;    // The header is present and we didn't specify a value for it...
                } else {
                    // Check if the header value is the one we specified...
                    return requestHeaderValue.ToLowerInvariant().Trim() == headerParts[1].Trim();
                }
            }

            return false;
        }

        public static void AddNoCacheHeaders(HttpResponse response) {
            // see: http://stackoverflow.com/a/2068407
            response.AddHeader("Cache-Control", "no-cache, no-store, must-revalidate");	// HTTP 1.1
            response.AddHeader("Pragma", "no-cache"); // HTTP 1.0
            response.AddHeader("Expires", "0"); // Proxies
        }

        public static string GetURL(string url, BaseAppUtils appUtils, string overrideApplicationUrl) {
            string finalUrl = url;
            // Check if we have the special http to https header
            string httpToHttpsProxyHeader = Settings.Get(Settings.Configs.HTTPtoHTTPSproxyHeader);

            if (!String.IsNullOrEmpty(httpToHttpsProxyHeader) && !Uri.IsWellFormedUriString(url, UriKind.Absolute)) {
                Uri bookmarkableURI = new Uri(BuiltInFunction.GetBookmarkableURL());

                if (url.StartsWith("/")) {
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + url;
                } else if (appUtils != null) {
                    string applicationUrl = appUtils.getImagePath(/*internalAccess*/false, /*includeSessionIdIfNeeded*/false, overrideApplicationUrl);
                    finalUrl = bookmarkableURI.GetLeftPart(UriPartial.Authority) + applicationUrl + url;
                }
            }
            return finalUrl;
        }

        public static string GetRequestURL(HttpRequest request) {
            //the mapping of Request.Url was fixed to add queryString (to become equivalent to dotnet)
            // but this method is used in External Extensions that in Java already are considering that querystring is not returned and append it @ the end
            
            Uri requestUrl = request.Url;

            // Change the scheme of the request url to reflect the RequestIsSecure
            return (RequestIsSecure(request) ? "https" : "http") + requestUrl.ToString().Substring(requestUrl.Scheme.Length);
        }

        public static string CheckUriSecurity(HttpRequest request, string uri) {
            // DO NOT replace with one receiving an Uri .. the "new Uri(uri)" might change the uri
            if (RequestIsSecure(request) && uri.ToLower().StartsWith("http")) {
                return "https" + uri.Substring(uri.IndexOf(":"));
            }
            return uri;
        }

        public static Process LaunchProcess(String command, String commandParams, String path, ProcessPriorityClass priority, string username, string domain, string password) {
            Process process = new Process();
            process.StartInfo = new ProcessStartInfo(command, commandParams);
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.WindowStyle = ProcessWindowStyle.Minimized;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            if (path != null) {
                process.StartInfo.WorkingDirectory = path;
            }

            process.StartInfo.UserName = username;
            process.StartInfo.Domain = domain;
            process.StartInfo.Password = new System.Security.SecureString();
            password.Apply(c => process.StartInfo.Password.AppendChar(c));
            process.StartInfo.Password.MakeReadOnly();

            process.Start();
            process.PriorityClass = priority;
            return process;
        }


        public static Process LaunchProcess(String command, String commandParams, String path, ProcessPriorityClass priority) {
            Process process = new Process();
            process.StartInfo = new ProcessStartInfo(command, commandParams);
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.CreateNoWindow = true;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            if (path != null) {
                process.StartInfo.WorkingDirectory = path;
            }
            process.Start();
            process.PriorityClass = priority;
            return process;
        }

        // launches a process
        public static Process LaunchProcess(String command, String commandParams, bool hidden, ProcessPriorityClass priority) {
            Process process = new Process();
            process.StartInfo = new ProcessStartInfo(command, commandParams);
            if (hidden) {
                process.StartInfo.CreateNoWindow = true;
                process.StartInfo.ErrorDialog = false;
            }
            process.Start();
            process.PriorityClass = priority;
            return process;
        }

        [Obsolete("Use LaunchProcess(String command, String commandParams, bool hidden, ProcessPriorityClass priority) instead.")]
        public static Process LaunchProcess(String command, String commandParams, bool hidden) {
            return LaunchProcess(command, commandParams, hidden, ProcessPriorityClass.Normal);
        }

        // waits for the end of a process maxTime time
        public static bool ProcessEnded(Process process, int maxTime) {
            return process.WaitForExit(maxTime);
        }

        public static string GetEspacePrettyNamePath(string eSpaceName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCaseESpaceName = eSpaceName.ToLower();
                if (heContext.GetESpacePrettyNames.ContainsKey(lCaseESpaceName)) {
                    return (string)(heContext.GetESpacePrettyNames[lCaseESpaceName]);
                }
            }
            return "/" + eSpaceName + "/";
        }

        public static List<string> GetPageRules(int eSpaceId, string PageName, HeContext heContext) {
            if (heContext.OsISAPIFilter.IsEnabled) {
                string lCasePageName = PageName.ToLower();
                if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                    return heContext.GetPageRules(eSpaceId)[lCasePageName];
                }
                // Remove any flow prefix in the name and try again: WebFlow1.MyPage -> MyPage
                int NonPrefixedPos = lCasePageName.IndexOf('.');
                if (NonPrefixedPos != -1) {
                    lCasePageName = lCasePageName.Substring(NonPrefixedPos + 1);
                    if (heContext.GetPageRules(eSpaceId).ContainsKey(lCasePageName)) {
                        return heContext.GetPageRules(eSpaceId)[lCasePageName];
                    }
                }
            }
            return null;
        }

        public static string FixHostIPForIPV6(string host) {
            return (host.Contains(":") && !host.StartsWith("[")) ? "[" + host + "]" : host;
        }
        //TODO change to new behaviour by default in P10 and assume in breaking changes
        private static string GetRequestRealIPOldBehaviour(HttpRequest request) {
            string requestIp = "";
            requestIp = request.Headers.Get("X-Forwarded-For");
            if (requestIp != null && requestIp.IndexOf(",") > 0)
                requestIp = requestIp.Substring(0, requestIp.IndexOf(",")).Trim();
            else if (requestIp == null || requestIp == "" || requestIp.ToLower() == "unknown")
                requestIp = request.UserHostAddress;
            return requestIp;
        }

        public static string GetRequestRealIP(HttpRequest request) {
            //Both GetRequestIPAddress from OMLProcessor.xif and GetIP from HTTPRequestHandler.xif call this method
            //Lifetime and ServiceCenter use the action from OMLProcessor and Users.oml uses the one from HTTPRequestHandler

            string requestIp = "";

            if (Settings.GetBool(Settings.Configs.EnableTrustedProxies)) {
                if (IsFromTrustedProxy(request.UserHostAddress)) {
                    requestIp = GetTrustedAddressFromForwardHeader(request.Headers.Get("X-Forwarded-For"));
                }

                if (requestIp.IsNullOrEmpty()) {
                    return request.UserHostAddress;
                } else {
                    return requestIp;
                }
            } else {
                return GetRequestRealIPOldBehaviour(request);
            }
        }

        public static string GetTrustedAddressFromForwardHeader(string header) {
            if (header.IsNullOrEmpty()) {
                return null;
            }
            string requestIp = "";
            string[] headerAddresses = header.Split(',');
            Array.Reverse(headerAddresses);
            foreach (string headerAddress in headerAddresses) {
                string address = headerAddress.Trim();
                if (IsFromTrustedProxy(address)) {
                    continue;
                } else {
                    requestIp = address;
                    break;
                }
            }
            if (!requestIp.IsEmpty() && IPAddressValidation(requestIp)) {
                return requestIp;
            }
            return null;
        }

        private static List<IPAddressRange> _trustableProxyAddresses = null;
        private static string _previousTrustableProxyAddress = null;

        public static bool IsFromTrustedProxy(string requestIPAddress) {
            IPAddress requestIp;

            if (!IPAddressValidation(requestIPAddress, out requestIp)) {
                return false;
            }

            string ipList = Settings.Get(RuntimePlatform.Settings.Configs.TrustedProxyAddresses);

            if (ipList.IsNullOrEmpty()) {
                return false;
            }

            if (!ipList.Equals(_previousTrustableProxyAddress)) {
                var trustableProxyAddresses = new List<IPAddressRange>();

                foreach (string ipRange in ipList.Split(new char[] { ';', ' ' })) {
                    IPAddressRange range = null;
                    if (IPAddressRange.TryParse(ipRange.Trim(), out range)) {
                        trustableProxyAddresses.Add(range);
                    }
                }

                lock (typeof(RuntimePlatformUtils)) {
                    _trustableProxyAddresses = trustableProxyAddresses;
                    _previousTrustableProxyAddress = ipList;
                }
            }

            foreach (var range in _trustableProxyAddresses) {
                if (range.Contains(requestIp)) {
                    return true;
                }
            }

            return false;
        }

        #region Obsolete methods

        // NOTE: These methods and properties only exist here because of compatibility reasons (old xifs may use them)
        [Obsolete("Please use the FileSystemUtils.PathSeparatorChar instead")]
        public static char PathSeparatorChar { get { return FileSystemUtils.PathSeparatorChar; } }

        [Obsolete("Please use the FileSystemUtils.PathSeparator instead")]
        public static string PathSeparator { get { return FileSystemUtils.PathSeparator; } }

        [Obsolete("Please use the FileSystemUtils.GetAllFiles instead")]
        public static IList GetAllFiles(string directoryPath, bool recursive) {
            return FileSystemUtils.GetAllFiles(directoryPath, recursive);
        }

        [Obsolete("Please use the FileSystemUtils.IsTemporary instead")]
        public static bool IsTemporary(OutSystemsPlatform platform, string fileName) {
            return FileSystemUtils.IsTemporary(platform, fileName);
        }

        [Obsolete("Please use the FileSystemUtils.FilePathHasExtension instead")]
        public static bool FilePathHasExtension(string filePath, ArrayList extensionsList) {
            return FileSystemUtils.FilePathHasExtension(filePath, extensionsList);
        }

        [Obsolete("Please use the FileSystemUtils.FilePathHasFile instead")]
        public static bool FilePathHasFile(string filePath, ArrayList filesList) {
            return FileSystemUtils.FilePathHasFile(filePath, filesList);
        }

        [Obsolete("Please use the FileSystemUtils.GetTemporaryDirectory instead")]
        public static string GetTemporaryDirectory() {
            return FileSystemUtils.GetTemporaryDirectory();
        }

        [Obsolete("Please use the FileSystemUtils.GetTemporaryFile instead")]
        public static string GetTemporaryFile() {
            return FileSystemUtils.GetTemporaryFile();
        }

        #endregion

        public static byte[] GetResourceBinary(string resource, string application) {
            try {
                return GetResourceBinaryInternal(resource, application);
            } catch (Exception e) {
                throw new InvalidOperationException("Could not access resource '{0}' in producer '{1}'. Make sure the reference is not outdated and both eSpaces are on the same Zone.".F(resource, application), e);
            }
        }

        private static byte[] GetResourceBinaryInternal(string resource, string application) {
            // Fetch from PTA if we're running inside one, on the owner of the resource. Otherwise get from owner's main area
            if (AppInfo.GetAppInfo().eSpaceName == application) {
                return File.ReadAllBytes(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, resource));
            } else {
                return File.ReadAllBytes(Path.Combine(HttpContext.Current.Server.MapPath("/" + application), resource));
            }
        }

        private static readonly Dictionary<string, string> extensionsToMimeTypes = new Dictionary<string, string>() {
            { "bmp", "image/bmp" },
            { "gif", "image/gif" },
            { "jpg", "image/jpg" },
            { "jpeg", "image/jpeg" },
            { "png", "image/png" },
        };

        public static string GetMIMEType(string extension) {
            return extensionsToMimeTypes.GetValueOrDefault(extension) ?? string.Empty;
        }

        private static ICompilerContext compilerContext;

        public static ICompilerContext GetCompilerContext() {
            if (compilerContext == null) {
                compilerContext = new ICompilerContext(
                    Settings.Get(Settings.Configs.Sandbox_OperatingSandboxMode).ToLower() == "true",
                    Settings.Get(Settings.Configs.Sandbox_BoxKeyName));
            }
            return compilerContext;
        }

        static RuntimePlatformUtils() {
            InitDefaultEncoding(IsJava());
        }
        public static string WebPageExtension {
            get {
                return IsJava() ? ".jsf" : ".aspx";
            }
        }

        public static string GetAdministrationEmail() {
            string email = String.Empty;

            using (Transaction tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                email = (string)DBRuntimePlatform.Instance.GetSitePropertyByName(tran, "AdministrationEmail", Constants.ServiceCenterName,
                    Constants.ServiceCenterName);
            }
            return email;
        }

        public static void SetupCurrentThreadCulture() {
            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-US");
            Thread.CurrentThread.CurrentUICulture = CultureInfo.GetCultureInfo("en-US");
        }

        internal static int GetCurrentDefaultTenantId() {
            var app = AppInfo.GetAppInfo();
            if (app != null) {
                using (Transaction trans = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                    return DBRuntimePlatform.Instance.GetDefaultTenantIdByUserProviderEspaceKey(trans, app.UserProviderEspaceKeyAsKey, "-");
                }
            }
            return 0;
        }

        internal static bool IsApplicationEnabled(int eSpaceId) {
            using (Transaction tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                return DBRuntimePlatform.Instance.GetApplicationEnabledForEspace(tran, eSpaceId);
            }
        }

        public static void ExecuteWithRetries(int maxRetries, Action actionToExecute) {
            ExecuteWithRetriesInfo(maxRetries, actionToExecute, (i, e) => { });
        }

        public static void ExecuteWithRetriesInfo(int maxRetries, Action actionToExecute, Action<int, Exception> logException) {
            Exception lastException = null;

            for (int i = 0; i < maxRetries; i++) {
                try {
                    lastException = null;
                    actionToExecute();
                } catch (Exception e) {
                    logException(i, e);
                    lastException = e;
                    continue;   // could be a temporary problem...
                }

                break;
            }

            if (lastException != null) {
                
                throw lastException;
            }
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId) {
            bool isDefault;
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/true, out isDefault);
        }

        public static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, out bool isDefault) {
            return GetWebReferenceEffectiveOrDefaultURL(webrefSSKey, eSpaceId, /*cacheValue*/false, out isDefault);
        }

        private static string GetWebReferenceEffectiveOrDefaultURL(string webrefSSKey, int eSpaceId, bool cacheValue, out bool isDefault) {
            bool innerIsDefault = false;
            Func<string> fetchFromDb = () => {
                using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                    using (IDataReader reader = DBRuntimePlatform.Instance.GetWebReferenceURLs(tran, webrefSSKey, eSpaceId)) {
                        if (reader.Read()) {
                            // get default url
                            var url = reader.SafeGet<string>("URL");
                            // get effective url
                            var effectiveUrl = reader.SafeGet<string>("Effective_URL");
                            if (effectiveUrl != null) {
                                // #484852 trim to convert oracle " " to ""
                                effectiveUrl = effectiveUrl.Trim();
                            }
                            if (effectiveUrl.IsEmpty()) {
                                innerIsDefault = true;
                                return url;
                            } else {
                                return effectiveUrl;
                            }
                        }
                        return string.Empty;
                    }
                }
            };


            if (cacheValue) {
                isDefault = false;
                return AppCache.GetESpaceCachedValue<string, string>(webrefSSKey, "WebReferenceURLCache", eSpaceId, dummy => fetchFromDb());
            } else {
                var result = fetchFromDb();
                isDefault = innerIsDefault;
                return result;
            }
        }

        public static WebReferenceConfiguration GetWebReferenceLoggingConfiguration(string webrefSSKey, int eSpaceId) {
            WebReferenceConfiguration configuration = new WebReferenceConfiguration();
            
            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                using (var reader = DBRuntimePlatform.Instance.GetWebReferenceLoggingConfiguration(tran, webrefSSKey, eSpaceId)) {
                    if (reader.Read()) {
                        var traceAll = reader.SafeGet<bool>("TRACEALL");
                        var traceErrors = reader.SafeGet<bool>("TRACEERRORS");

                        configuration = new WebReferenceConfiguration(traceErrors, traceAll);
                    }
                }
            }
            return configuration;
        }

        public const string EditRecordDefinedInParentScreen = "Parent-Screen";


        public static void LogSlowExtensionCall(DateTime startTime, string description) {
            if (!ExtensionTresholdKnown) {
                lock (ExtensionTresholdLockObject) {
                    if (!ExtensionTresholdKnown) {
                        ExtensionTreshold = Settings.GetInt(Settings.Configs.Log_SlowExtensionCallInMs);
                        ExtensionTresholdKnown = true;
                    }
                }
            }

            double duration = DateTime.Now.Subtract(startTime).TotalMilliseconds;
            if (ExtensionTreshold == 0) return;
            if (duration > ExtensionTreshold) {
                HeContext heContext = null;
                if (System.Web.HttpContext.Current != null) {
                    AppInfo info = AppInfo.GetAppInfo();
                    if (info != null) {

                        if (info.eSpaceId == 0) {
                            return;
                        }

                        heContext = AppInfo.GetAppInfo().OsContext;
                    }
                }
                OutSystems.HubEdition.RuntimePlatform.Log.GeneralLog log = new OutSystems.HubEdition.RuntimePlatform.Log.GeneralLog();
                log.Write(
                    startTime,
                    (heContext != null ? heContext.Session.SessionID : ""),
                    (heContext != null ? heContext.AppInfo.eSpaceId : 0),
                    (heContext != null ? heContext.AppInfo.Tenant.Id : 0),
                    (heContext != null ? heContext.Session.UserId : 0),
                    description + " took " + Convert.ToInt32(duration) + " ms",
                    OutSystems.HubEdition.RuntimePlatform.Log.GeneralLogType.WARNING.ToString(),
                    "SLOWEXTENSION",
                    "");
            }

        }

        public static void SaveTemporaryAndroidDownload(string guid, string mimeType, DateTime expireDate, byte[] fileContent, string filename, string disposition) {

            using (var tran = DatabaseAccess.ForSystemDatabase.GetRequestTransaction()) {
                var hash = RuntimeCommon.Cryptography.SecureHashHelper.Hash(fileContent);
                DBRuntimePlatform.InsertTemporaryAndroidDownload(tran, guid, mimeType, expireDate, fileContent, hash, filename, disposition);
            }
        }

        public static bool GetTemporaryAndroidDownload(string guid, out string mimeType, out DateTime expireDate, out byte[] fileContent, out string filename, out string disposition) {

            mimeType = null;
            expireDate = DateTime.MinValue;
            fileContent = null;
            filename = null;
            disposition = null;

            using (var tran = DatabaseAccess.ForSystemDatabase.GetReadOnlyTransaction()) {
                using (IDataReader reader = DBRuntimePlatform.GetTemporaryAndroidDownload(tran, guid)) {
                    if (reader.Read()) {
                        mimeType = reader.SafeGet<string>("MIMETYPE");
                        expireDate = reader.SafeGet<DateTime>("EXPIRES");
                        fileContent = reader.SafeGet<byte[]>("CONTENT");
                        filename = reader.SafeGet<string>("FILENAME");
                        disposition = reader.SafeGet<string>("DISPOSITION");
                        return true;
                    }
                }
            }
            return false;
        }


        public static string GetDatabaseImagePath(string entityName, string attributeName, string idValue, string fileName) {
            string entityDetails = RC4CryptHelper.EncryptWithFixedKey(entityName + "/" + attributeName + "/" + idValue);
            entityDetails = entityDetails.Replace("+", "-").Replace("/", "_");    /* Replace invalid URL chars */
            return "_image" + WebPageExtension + "/" + entityDetails + "/" + fileName;
        }

        public static RequestTracer GetRequestTracer() {
            if (HttpContext.Current != null &&
                HttpContext.Current.Items["osContext"] != null) {
                return ((HeContext)HttpContext.Current.Items["osContext"]).RequestTracer;
            }

            return null;
        }

        private static Dictionary<string, EspaceProperties> requestEventespaceProperties = new Dictionary<string, EspaceProperties>();

        private static Object requestEventespacePropertiesLocker = new Object();

        public static EspaceProperties GetRequestEventEspaceProperties(string moduleKey) {
            var app = AppInfo.GetAppInfo();
            if (app != null && app.eSpaceUID == moduleKey) {
                return app.Properties;
            }
            lock (requestEventespacePropertiesLocker) {
                EspaceProperties properties;

                if (!requestEventespaceProperties.TryGetValue(moduleKey, out properties)) {

                    properties = new EspaceProperties(moduleKey);

                    requestEventespaceProperties.Add(moduleKey, properties);
                }

                return properties;
            }
        }
    }

    // WARNING:
    // should you change any of these values
    // also check OutSystems.HubEdition.RuntimePlatform.Web.JavaScriptManager.clientScript
    // and change the hardcoded value there!
    public enum CacheInvalidationMangleDepth {
        None = 0,
        PlatformInserted = 10,
        UserCSS = 20,
        All = 1000
    }

    // WARNING: Needs to be sync'ed with Service Center!
    public enum PathRuleKind {
        PassThroughESpace = 1,
        PassThroughVDir = 2,
        ESpacePrettyName = 3,
        Custom = 4
    }

}
